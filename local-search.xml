<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>python爬虫</title>
    <link href="/2022/12/28/python%E7%88%AC%E8%99%AB/"/>
    <url>/2022/12/28/python%E7%88%AC%E8%99%AB/</url>
    
    <content type="html"><![CDATA[<ul><li><code>requests</code>模块</li><li>数据解析<ul><li><code>bs4</code>模块</li><li>正则表达式</li><li><code>xpath</code></li></ul></li><li>反爬机制<ul><li><code>UA</code>识别 –&gt; <code>UA</code>伪装</li><li>动态数据加载<ul><li><code>Ajax</code></li><li><code>JS</code></li><li>伪标签</li></ul></li><li><code>Cookie</code>机制</li><li><code>IP</code>高频请求封禁 –&gt; 代理IP（透明、匿名、高匿）</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Python爬虫</category>
      
    </categories>
    
    
    <tags>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go-基于TCP协议自定义应用层协议</title>
    <link href="/2022/12/20/TCP%E6%9C%8D%E5%8A%A1%E5%99%A8/go-%E5%9F%BA%E4%BA%8ETCP%E5%8D%8F%E8%AE%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/12/20/TCP%E6%9C%8D%E5%8A%A1%E5%99%A8/go-%E5%9F%BA%E4%BA%8ETCP%E5%8D%8F%E8%AE%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><p>我们熟知的网络是分层的：</p><ul><li>OSI Model（七层）</li><li>TCP&#x2F;IP Model（四层）</li></ul><p>当前主流网络模型的实现是分为四层的TCP&#x2F;IP模型，</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h9a9tkjsc8j31hc0t3dh2.jpg" alt="OSI和TCP/IP模型"></p><p>通常情况下，更多关注的是<strong>传输层</strong>和<strong>应用层</strong></p><h1 id="TCP-x2F-IP-Model"><a href="#TCP-x2F-IP-Model" class="headerlink" title="TCP&#x2F;IP Model"></a>TCP&#x2F;IP Model</h1><p>其实现了<strong>两种传输层协议</strong>：</p><ul><li><p>TCP</p><p>面向连接的流协议，为通信的两端提供稳定可靠的数据传输服务</p></li><li><p>UDP</p><p>提供了无需建立连接就可以传输数据包的方法</p></li></ul><p>日常开发中使用最多的是<strong>TCP协议</strong>，根据<strong>传输层</strong>里的协议，可以去构建满足用户需求的<strong>应用层协议</strong>，例如HTTP协议。这种方法就是<strong>基于传输层暴露给开发者的编程接口，实现应用层的自定义应用协议</strong></p><h2 id="传输层暴露的接口"><a href="#传输层暴露的接口" class="headerlink" title="传输层暴露的接口"></a>传输层暴露的接口</h2><p>最常见的就是<strong>套接字（socket）</strong>，可以直接基于socket编程实现应用层通信业务</p><p>那么，如何基于socket进行网络编程呢？</p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p><strong>实现一个基于TCP的自定义应用层协议的通信服务端</strong></p><ol><li><p><strong>输入</strong>：基于传输层自定义的应用层协议规范，根据TCP流协议的传输机制需要<strong>自定义数据流的边界</strong>：</p><ol><li><p><strong>二进制模式</strong>：采用长度字段标识独立数据包的边界，常见协议有MQTT、SMPP，<em>因为二进制编码比文本模式更紧凑也更高效，所以在这个问题中采用了二进制模式</em>：</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h9aagcz3tfj30ra0i6wgs.jpg" alt="二进制模式"></p></li><li><p><strong>文本模式</strong>：采用特定的分隔符标识边界，HTTP协议就是这种方式</p></li></ol></li><li><p><strong>通信两端的通信流程</strong></p><p><strong>“请求&#x2F;响应”通信模型</strong>：</p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h9aajx5f25j30i40fc3z0.jpg" alt="请求/响应通信模型" style="zoom:67%;" /></li></ol><p>我们的目的就是<strong>实现支持这个协议通信的服务端</strong></p><p>需要了解的技术点：</p><ul><li>socket编程模型</li><li>网络I&#x2F;O操作</li><li>数据（针对字节）的操作</li></ul><h1 id="TCP-Socket编程模型"><a href="#TCP-Socket编程模型" class="headerlink" title="TCP Socket编程模型"></a>TCP Socket编程模型</h1><p>Socket编程模型也就是<strong>网络I&#x2F;O模型</strong>：即定义<strong>应用线程和操作系统内核之间的交互行为模式</strong>，通常用<strong>阻塞（Blocking）&#x2F;非阻塞（Non-Blocking）</strong>去描述网络I&#x2F;O模型</p><p>如果内核等到数据全部就绪后才返回，这种行为模式就是<strong>阻塞</strong></p><p>如果内核没有就绪也返回内容这种行为模式就是<strong>非阻塞</strong></p><h2 id="阻塞I-x2F-O（Blocking-I-x2F-O）"><a href="#阻塞I-x2F-O（Blocking-I-x2F-O）" class="headerlink" title="阻塞I&#x2F;O（Blocking I&#x2F;O）"></a>阻塞I&#x2F;O（Blocking I&#x2F;O）</h2><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h9aewl49dvj30mc0gw0ta.jpg" alt="Blocking I/O" style="zoom:67%;" /><p>这种模型下，一个线程仅能处理一个网络连接上的数据通信。无论连接上有没有数据，线程也只能阻塞在对Socket的读操作上（以等待对端的数据）。</p><p><em><strong>低效但容易</strong></em></p><h2 id="非阻塞I-x2F-O（Non-Blocking-I-x2F-O）"><a href="#非阻塞I-x2F-O（Non-Blocking-I-x2F-O）" class="headerlink" title="非阻塞I&#x2F;O（Non-Blocking I&#x2F;O）"></a>非阻塞I&#x2F;O（Non-Blocking I&#x2F;O）</h2><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h9af3u2takj30jm0i8t9w.jpg" alt="Non-Blocking I/O" style="zoom:67%;" /><p>对比Blocking I&#x2F;O，在非阻塞模型下，反馈是及时的，没有准备好数据就以错误码形式返回“未就绪”的状态</p><p>非阻塞模型中，请求发起者会通过<strong>轮询</strong>的方式，一次次的发起I&#x2F;O请求直到读取到数据</p><p><em><strong>对CPU计算资源的极大浪费</strong></em></p><h2 id="I-x2F-O多路复用（I-x2F-O-Multiplexing）"><a href="#I-x2F-O多路复用（I-x2F-O-Multiplexing）" class="headerlink" title="I&#x2F;O多路复用（I&#x2F;O Multiplexing）"></a>I&#x2F;O多路复用（I&#x2F;O Multiplexing）</h2><p>综合考虑，这种是建立在内核提供的多路复用函数select&#x2F;poll等（和性能更好的epoll等函数）基础上的I&#x2F;O多路复用模型</p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h9afjeerrkj30ls0hymy5.jpg" alt="I/O多路复用" style="zoom:67%;" /><p>将需要进行I&#x2F;O操作的Socket，都添加到多路复用函数中，此时阻塞，当某个Socket具备可读条件时，多路复用函数调用返回，然后用户线程会针对这个Socket发起网络I&#x2F;O请求</p><ul><li><strong>一个应用线程可以同时处理多个Socket</strong></li><li><strong>由内核实现可读&#x2F;可写事件的通知，避免了轮询带来的CPU资源的浪费</strong></li><li><strong>但同时复杂度提高</strong></li></ul><h1 id="Go语言的Socket编程模型"><a href="#Go语言的Socket编程模型" class="headerlink" title="Go语言的Socket编程模型"></a>Go语言的Socket编程模型</h1><p>前面说过：</p><ul><li>阻塞I&#x2F;O模型是对开发人员最友好的</li><li>I&#x2F;O多路复用模型是通过<strong>回调割裂执行流</strong></li></ul><p>Go选择了<strong>阻塞I&#x2F;O模型</strong>，只需在Goroutine中以最简单、最易用的这种方式进行Socket操作就行</p><p>Goroutine开销小，让每个Goroutine处理一个TCP连接成为可能，在高并发下依然出色</p><p>网络I&#x2F;O操作都是系统调用，Goroutine执行一旦阻塞在系统调用上，就会导致运行Goroutine的线程也被阻塞，于是Go在运行时实现了网络轮询器（netpoller），只阻塞执行网络I&#x2F;O操作的Goroutine，而不阻塞线程</p><h1 id="网络I-x2F-O操作"><a href="#网络I-x2F-O操作" class="headerlink" title="网络I&#x2F;O操作"></a>网络I&#x2F;O操作</h1><h2 id="socket监听（listen）与接收连接（accept）"><a href="#socket监听（listen）与接收连接（accept）" class="headerlink" title="socket监听（listen）与接收连接（accept）"></a>socket监听（listen）与接收连接（accept）</h2><p>服务端程序采用一个Goroutine处理一个连接：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleConn</span><span class="hljs-params">(c net.Conn)</span></span> &#123;<br><span class="hljs-keyword">defer</span> c.Close()<br><span class="hljs-comment">// read and write</span><br><span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// listen</span><br>l, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:8888&quot;</span>)<br><span class="hljs-comment">// error</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;listen error:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// accept</span><br><span class="hljs-keyword">for</span> &#123;<br>c, err := l.Accept()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;accept error:&quot;</span>, err)<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-comment">// start a new goroutine to handle</span><br><span class="hljs-comment">// the new connection</span><br><span class="hljs-keyword">go</span> handleConn(c)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务端做好了listen和Accept之后，客户端就可以和服务端连接了</p><h2 id="向服务端建立TCP连接"><a href="#向服务端建立TCP连接" class="headerlink" title="向服务端建立TCP连接"></a>向服务端建立TCP连接</h2><p>当服务端Listen + Accept的结构建立好之后，客户端就可以使用<code>net.Dial</code>或<code>net.DialTimeout</code>向服务端发送建立连接请求：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">conn, err := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8888&quot;</span>)<br>conn, err := net.DialTimeout(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8888&quot;</span>, <span class="hljs-number">2</span> * time.Second)<br></code></pre></td></tr></table></figure><p><code>Dial</code>函数向服务端发送TCP连接，这个函数会一直阻塞，直到连接成功或者失败后才会返回，但是DialTimeout函数带有超时机制，如果连接耗时大于超时时间，这个函数才能返回超时错误</p><p>下面，对于客户端来说，连接的建立还可能会遇到几种特殊情形：</p><h3 id="网络不可达或对方服务未启动"><a href="#网络不可达或对方服务未启动" class="headerlink" title="网络不可达或对方服务未启动"></a>网络不可达或对方服务未启动</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">dial <span class="hljs-type">error</span>: dial tcp :<span class="hljs-number">8888</span>: getsockopt: connection refused<br></code></pre></td></tr></table></figure><h3 id="对方服务的listen-backlog-队列满"><a href="#对方服务的listen-backlog-队列满" class="headerlink" title="对方服务的listen backlog 队列满"></a>对方服务的listen backlog 队列满</h3><p>当对方的服务器瞬间有大量的客户端尝试向服务端建立连接时，服务端可能会出现 listen backing 队列满，接收Accept不及时的情况</p><p>会导致客户端的Dial调用阻塞，直到backing队列中出现槽位才能建立上连接</p><h3 id="若网络延迟较大，Dial将阻塞并超时"><a href="#若网络延迟较大，Dial将阻塞并超时" class="headerlink" title="若网络延迟较大，Dial将阻塞并超时"></a>若网络延迟较大，Dial将阻塞并超时</h3><p>如果网络延迟较大，TCP连接的建立过程（三次握手）会更难，会经历各种的丢包，时间消耗自然也会更长，可能会出现阻塞</p><h2 id="全双工通信"><a href="#全双工通信" class="headerlink" title="全双工通信"></a>全双工通信</h2><p>当客户端调用Dial成功，那么这个时候就在客户端与服务端之间建立起了一条全双工的通信通道，客户端和服务端通过各自获取得到的Socket，可以实现边发送、边接收的功能<img src="https://tva1.sinaimg.cn/large/008vxvgGly1h9ajbx50a2j30sc08c0tb.jpg" alt="全双工通信通道"></p><p>明白了这个通信原理后，再理解下面的Socket操作就容易许多了</p><h2 id="Socket读操作"><a href="#Socket读操作" class="headerlink" title="Socket读操作"></a>Socket读操作</h2><h3 id="Socket中无数据的场景"><a href="#Socket中无数据的场景" class="headerlink" title="Socket中无数据的场景"></a>Socket中无数据的场景</h3><p>连接建立好后，客户端没有向服务端发送数据，那么服务端就会阻塞在Socket的读操作上，执行这个操作的Goroutine会被挂起，Go运行时会监视这个Socket，直到有数据读事件才完成读操作</p><h3 id="Socket中有部分数据"><a href="#Socket中有部分数据" class="headerlink" title="Socket中有部分数据"></a>Socket中有部分数据</h3><p>数据数量小于一次读操作期望读出的数据长度，则读操作会成功读出这部分数据，并返回，而不是等待期望长度数据全部读取后再返回</p><h3 id="Socket中有足够数据"><a href="#Socket中有足够数据" class="headerlink" title="Socket中有足够数据"></a>Socket中有足够数据</h3><p>数据长度大于等于一次Read操作期望读出的数据长度，将会成功读取出这部分的数据并返回</p><h3 id="设置Read操作超时"><a href="#设置Read操作超时" class="headerlink" title="设置Read操作超时"></a>设置Read操作超时</h3><p>可以通过<code>net.Conn</code>提供的<code>SetReadDeadline</code>方法，设置读操作的超时时间，当超时后仍然没有数据可读的情况下，Read操作会解除阻塞并返回超时错误</p><p>这个方法接收的是绝对时间，一旦超时要重新设置Deadline</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleConn</span><span class="hljs-params">(c net.Conn)</span></span> &#123;<br><span class="hljs-keyword">defer</span> c.Close()<br><span class="hljs-comment">// read and write</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// read from the connection</span><br><span class="hljs-keyword">var</span> buf = <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">128</span>)<br>c.SetReadDeadline(time.Now().Add(time.Second))<br>n, err := c.Read(buf)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;conn read %d bytes, error: %s&quot;</span>, n, err)<br><span class="hljs-keyword">if</span> nerr, ok := err.(net.Error); ok &amp;&amp; nerr.Timeout() &#123;<br><span class="hljs-comment">// 进行其他业务的逻辑处理</span><br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br>log.Printf(<span class="hljs-string">&quot;read %d bytes, content is %s\n&quot;</span>, n, <span class="hljs-type">string</span>(buf[:n]))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Socket写操作"><a href="#Socket写操作" class="headerlink" title="Socket写操作"></a>Socket写操作</h2><p>通过调用<code>net.Conn</code>实例的Write方法，可以将数据写入Socket</p><h3 id="写阻塞"><a href="#写阻塞" class="headerlink" title="写阻塞"></a>写阻塞</h3><p>根据全双工通信的原理，每个方向都有数据缓冲的区域，当发送方将对方的接收缓冲区和自己的发送缓冲区都写满后，再调用Write方法就会出现阻塞</p><p>客户端逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// connection</span><br>log.Println(<span class="hljs-string">&quot;begin dial...&quot;</span>)<br>conn, err := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:8888&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(<span class="hljs-string">&quot;dial error&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> conn.Close()<br>log.Println(<span class="hljs-string">&quot;dial ok&quot;</span>)<br><br><span class="hljs-comment">// write</span><br>data := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">65536</span>)<br><span class="hljs-keyword">var</span> total <span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> &#123;<br>n, err := conn.Write(data)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>total += n<br>log.Printf(<span class="hljs-string">&quot;write %d bytes, error: %s\n&quot;</span>, n, err)<br><span class="hljs-keyword">break</span><br>&#125;<br>total += n<br>log.Printf(<span class="hljs-string">&quot;write %d bytes this time, %d bytes in total\n&quot;</span>, n, total)<br>&#125;<br><br>log.Printf(<span class="hljs-string">&quot;write %d bytes in total\n&quot;</span>, total)<br>&#125;<br></code></pre></td></tr></table></figure><p>服务端逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleConn</span><span class="hljs-params">(c net.Conn)</span></span> &#123;<br><span class="hljs-keyword">defer</span> c.Close()<br>time.Sleep(<span class="hljs-number">10</span> * time.Second)<br><br><span class="hljs-keyword">for</span> &#123;<br>time.Sleep(<span class="hljs-number">5</span> * time.Second)<br><span class="hljs-keyword">var</span> buf = <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">60000</span>)<br>log.Println(<span class="hljs-string">&quot;start to read from conn&quot;</span>)<br>n, err := c.Read(buf)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;conn read %d bytes, error: %s\n&quot;</span>, n, err)<br><span class="hljs-keyword">if</span> nerr, ok := err.(net.Error); ok &amp;&amp; nerr.Timeout() &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>&#125;<br>log.Printf(<span class="hljs-string">&quot;read %d bytes, content is %s\n&quot;</span>, n, <span class="hljs-type">string</span>(buf[:n]))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="写入部分数据"><a href="#写入部分数据" class="headerlink" title="写入部分数据"></a>写入部分数据</h3><p>突然中断服务端的接收，有的数据会显示被写入，但其实没有真正被写入</p><h3 id="写入超时"><a href="#写入超时" class="headerlink" title="写入超时"></a>写入超时</h3><p>部分数据会写入</p><h2 id="并发Socket读写"><a href="#并发Socket读写" class="headerlink" title="并发Socket读写"></a>并发Socket读写</h2><p>多个Goroutine对同一个conn进行Read的意义并不大，但是存在着进行Write的情况</p><p>每次 Write 操作都是受 lock 保护，直到这次数据全部写完才会解锁。</p><h2 id="Socket关闭"><a href="#Socket关闭" class="headerlink" title="Socket关闭"></a>Socket关闭</h2><ul><li><p>有数据关闭</p><p>客户端关闭连接，但是Socket中还有服务端未读取的数据，这时会将剩余的数据读取出来，再返回io.EOF错误码代表连接关闭</p></li><li><p>无数据关闭</p><p>直接返回io.EOF错误码代表连接关闭</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>TCP服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go_web开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go协程--互斥锁和读写锁</title>
    <link href="/2022/12/19/go%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/go%E5%8D%8F%E7%A8%8B-%E4%BA%92%E6%96%A5%E9%94%81%E5%92%8C%E8%AF%BB%E5%86%99%E9%94%81/"/>
    <url>/2022/12/19/go%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/go%E5%8D%8F%E7%A8%8B-%E4%BA%92%E6%96%A5%E9%94%81%E5%92%8C%E8%AF%BB%E5%86%99%E9%94%81/</url>
    
    <content type="html"><![CDATA[<p>面对并发问题的时候，我们应该始终优先考虑使用channel，如果channel解决不了，不得不使用共享内存的方式来实现并发编程的，那就是Golang中的锁机制</p><p>在Golang的sync包中，有两个很重要的锁类型</p><ul><li><code>Mutex</code>——互斥锁</li><li><code>RWMutex</code>——读写锁</li></ul><h1 id="互斥锁：Mutex"><a href="#互斥锁：Mutex" class="headerlink" title="互斥锁：Mutex"></a>互斥锁：Mutex</h1><p>使用互斥锁是为了保护一个资源不会因为并发操作而引起冲突导致数据不准确</p><p>当有多个协程对一个不具备原子性的过程进行处理的时候，如果不加上锁机制，会导致冲突从而导致数据不准确</p><h2 id="Mutex锁定义方法"><a href="#Mutex锁定义方法" class="headerlink" title="Mutex锁定义方法"></a>Mutex锁定义方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 第一种</span><br><span class="hljs-keyword">var</span> lock *sync.Mutex<br>lock = <span class="hljs-built_in">new</span>(sync.Mutex)<br><br><span class="hljs-comment">// 第二种</span><br>lock := &amp;sync.Mutex&#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(count *<span class="hljs-type">int</span>, wg *sync.WaitGroup, lock *sync.Mutex)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;<br><span class="hljs-comment">// 加锁</span><br>lock.Lock()<br>*count = *count + <span class="hljs-number">1</span><br><span class="hljs-comment">// 解锁</span><br>lock.Unlock()<br>&#125;<br>wg.Done()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>lock := &amp;sync.Mutex&#123;&#125;<br>count := <span class="hljs-number">0</span><br><br><span class="hljs-comment">// WaitGroup</span><br>wg.Add(<span class="hljs-number">3</span>)<br><br><span class="hljs-keyword">go</span> add(&amp;count, &amp;wg, lock)<br><span class="hljs-keyword">go</span> add(&amp;count, &amp;wg, lock)<br><span class="hljs-keyword">go</span> add(&amp;count, &amp;wg, lock)<br><br>wg.Wait()<br>fmt.Println(<span class="hljs-string">&quot;count的值为&quot;</span>, count)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意</p></blockquote><ul><li>同一协程里面，不要在尚未解锁时再次使用加锁</li><li>同一协程里面，不要对已解锁的锁再次解锁</li><li>加了锁后，要解锁，必要时使用defer</li></ul><h1 id="读写锁：RWMutex"><a href="#读写锁：RWMutex" class="headerlink" title="读写锁：RWMutex"></a>读写锁：RWMutex</h1><p>限于Mutex同一时刻只能有一个线程执行，在某些情况下，效率非常低，于是就有了RWMutex，<strong>将程序对资源的访问分为读操作和写操作</strong>：</p><ul><li>为了保证数据的安全，规定当有人还在读取数据（即读锁占用）时，不允许有人更新这个数据（即写锁会阻塞）</li><li>为了保证程序的效率，多个人（线程）读取数据（拥有读锁）时，互不影响不会造成阻塞，不会像Mutex那样只允许有一个人（线程）读取同一个数据</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 第一种</span><br><span class="hljs-keyword">var</span> lock *sync.RWMutex<br>lock = <span class="hljs-built_in">new</span>(sync.RWMutex)<br><br><span class="hljs-comment">// 第二种</span><br>lock := &amp;sync.RWMutex&#123;&#125;<br></code></pre></td></tr></table></figure><p>提供了两种锁，每种锁对应两个方法，为了避免死锁，两个方法要成对出现，必要时请使用defer</p><ul><li>读锁：调用Rlock开启锁，调用RUnlock释放锁</li><li>写锁：调用Lock方法开启锁，调用Unlock释放锁（和Mutex类似）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>lock := &amp;sync.RWMutex&#123;&#125;<br><span class="hljs-comment">// 写锁</span><br>lock.Lock()<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;第 %d 个协程准备开始.. \n&quot;</span>, i)<br><span class="hljs-comment">// 读锁</span><br>lock.RLock()<br>fmt.Printf(<span class="hljs-string">&quot;第 %d 个协程获得读锁, sleep 1s 后，释放锁\n&quot;</span>, i)<br>time.Sleep(time.Second)<br>lock.RUnlock()<br>&#125;(i)<br>&#125;<br><br>time.Sleep(<span class="hljs-number">2</span> * time.Second)<br><br>fmt.Println(<span class="hljs-string">&quot;准备释放写锁，读锁不再堵塞&quot;</span>)<br><span class="hljs-comment">// 写锁一释放，读锁就自由了</span><br>lock.Unlock()<br><br><span class="hljs-comment">// 由于会等到读锁全部释放，才能获得写锁</span><br><span class="hljs-comment">// 因为这里一定会在上面4个协程全部完成才能往下走</span><br>lock.Lock()<br>fmt.Println(<span class="hljs-string">&quot;程序退出...&quot;</span>)<br>lock.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">第 <span class="hljs-number">2</span> 个协程准备开始.. <br>第 <span class="hljs-number">0</span> 个协程准备开始.. <br>第 <span class="hljs-number">1</span> 个协程准备开始.. <br>第 <span class="hljs-number">3</span> 个协程准备开始.. <br>准备释放写锁，读锁不再堵塞<br>第 <span class="hljs-number">0</span> 个协程获得读锁, sleep <span class="hljs-number">1</span>s 后，释放锁<br>第 <span class="hljs-number">1</span> 个协程获得读锁, sleep <span class="hljs-number">1</span>s 后，释放锁<br>第 <span class="hljs-number">3</span> 个协程获得读锁, sleep <span class="hljs-number">1</span>s 后，释放锁<br>第 <span class="hljs-number">2</span> 个协程获得读锁, sleep <span class="hljs-number">1</span>s 后，释放锁<br>程序退出...<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>go基础回顾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go协程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go协程--WaitGroup</title>
    <link href="/2022/12/19/go%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/go%E5%8D%8F%E7%A8%8B-WaitGroup/"/>
    <url>/2022/12/19/go%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/go%E5%8D%8F%E7%A8%8B-WaitGroup/</url>
    
    <content type="html"><![CDATA[<p>前面了解了goroutine和channel，当时为了保证main goroutine在所有的goroutine都执行完毕后退出，用了<code>time.Sleep()</code>这种方式</p><p>但是在实际开发中，时间是不可预测的，sleep的时间长了就会导致主程序阻塞，少了就会导致有的子协程的任务没法完成</p><p>那么，如何优雅的处理这种情况呢？</p><h1 id="使用channel来标记完成"><a href="#使用channel来标记完成" class="headerlink" title="使用channel来标记完成"></a>使用channel来标记完成</h1><blockquote><p>不要通过共享内存来通信，要通过通信来共享内存</p></blockquote><p>前面知道了channel可以实现多个协程之间的通信，那么我们就可以去定义一个channel，在任务完成了之后，向channel中写入true，然后在主协程读取到true，就认为子协程已经执行完毕</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>fmt.Println(i)<br>&#125;<br>    <span class="hljs-comment">// 向channel中写入true</span><br>done &lt;- <span class="hljs-literal">true</span><br>&#125;()<br>  <span class="hljs-comment">// 读取channel中的true</span><br>&lt;-done<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="使用WaitGroup"><a href="#使用WaitGroup" class="headerlink" title="使用WaitGroup"></a>使用WaitGroup</h1><p>当协程数很少的时候，使用channel并不会有什么问题，但是当协程数多的时候，channel也就会多起来，代码就会非常复杂，这个时候就可以用到<strong>sync包提供的WaitGroup类型</strong></p><p>WaitGroup只要实例化了就能用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> 实例名 sync.WaitGroup<br></code></pre></td></tr></table></figure><p>实例化完了以后，就能够使用它的几个方法：</p><ul><li>Add：初始值为0，传入的值会往计数器上加，这里直接传入你子协程的数量就行</li><li>Done：当某个子协程完成后，可以使用这种方法，会从计数器上减一，通常可以用defer来调用</li><li>Wait：阻塞当前协程，直到实例里的计数器归零</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">(x <span class="hljs-type">int</span>, wg *sync.WaitGroup)</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;worker%d: %d\n&quot;</span>, x, i)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br>wg.Add(<span class="hljs-number">2</span>)<br><br><span class="hljs-keyword">go</span> worker(<span class="hljs-number">1</span>, &amp;wg)<br><span class="hljs-keyword">go</span> worker(<span class="hljs-number">2</span>, &amp;wg)<br><br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><p>通过这种方式可以实现一主多子多协程协作方式</p>]]></content>
    
    
    <categories>
      
      <category>go基础回顾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go协程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go协程--channel</title>
    <link href="/2022/12/19/go%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/go%E5%8D%8F%E7%A8%8B-channel/"/>
    <url>/2022/12/19/go%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/go%E5%8D%8F%E7%A8%8B-channel/</url>
    
    <content type="html"><![CDATA[<p>上篇介绍了<code>goroutine</code>，它是Go语言程序的并发体的话，那么<code>channel</code>（信道）就是它们之间的通信机制，也就是可以让一个<code>goroutine</code>和另一个<code>goroutine</code>传输信息的通道，也就是信道</p><p><code>channel</code>，就是一个管道，连接了多个goroutine程序，是一种队列式的数据结构，遵循先入先出的规则</p><h1 id="定义、使用channel"><a href="#定义、使用channel" class="headerlink" title="定义、使用channel"></a>定义、使用channel</h1><p>每个channel只能传递一种数据类型的数据，所以在声明的时候，要指定数据类型：</p><p><code>var 信道实例 chan 信道类型</code></p><p>声明后的默认值为<code>nil</code>，必须使用<code>make</code>函数进行初始化：</p><p><code>信道实例 = make(chan 信道类型)</code></p><p>或者直接就是:</p><p><code>信道实例 := make(chan 信道类型)</code></p><p>假如我要定义一个传输int类型的信道，可以这样写：</p><p><code>pipline := make(chan int)</code></p><p>定义好了信道之后，<strong>对信道中的数据操作也就是发送和读取数据</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 定义channel</span><br>pipline := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><br><span class="hljs-comment">// 向channel中发送数据</span><br>pipline&lt;- <span class="hljs-number">200</span><br><br><span class="hljs-comment">// 从信道中取出数据，将数据赋值给mydate</span><br>mydate := &lt;-pipline<br></code></pre></td></tr></table></figure><p>信道用完了之后，<strong>就可以对信道进行关闭，避免有人一直等待</strong>，<strong>但是关闭了信道之后，接收方依然可以从信道中读取到数据，只不过接收到的永远是0</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">close</span>(pipline)<br></code></pre></td></tr></table></figure><p><strong>如何判断一个channel是否已经被关闭？</strong></p><p>当从信道中读取数据时，可以有多个返回值，第二个返回值能够表示信道是否已经被关闭，如果关闭了就是<code>false</code>，没有关闭就是<code>true</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">x, ok := &lt;-pipline<br></code></pre></td></tr></table></figure><h2 id="channel的容量和长度"><a href="#channel的容量和长度" class="headerlink" title="channel的容量和长度"></a>channel的容量和长度</h2><p>通过<code>make</code>函数可以指定信道的容量（可以缓存的数据），不填的话默认为0：</p><ul><li>当容量为0时，channel中不能存放数据，发送数据时，要求必须立马有人接收，这种channel被称为<strong>无缓冲channel</strong></li><li>当容量为1时，只能存放一个数据，再向里面发送数据时，会造成程序堵塞（<strong>利用这一点可以使用信道来做锁</strong>）</li><li>当容量大于1时，channel中能存放多个数据，可以用于多个协程之间的通信管道，共享资源</li></ul><p><strong>可以使用cap来获取容量，使用len来获取长度</strong></p><h1 id="缓冲channel和无缓冲channel"><a href="#缓冲channel和无缓冲channel" class="headerlink" title="缓冲channel和无缓冲channel"></a>缓冲channel和无缓冲channel</h1><ul><li>缓冲channel</li></ul><p>​发送端和接收端可以处于<strong>异步状态</strong></p><ul><li><p>无缓冲channel</p><p>接收端必须先于发送端准备好，确保可以立马接收数据，否则发送端会阻塞，即必须处于<strong>同步状态</strong></p></li></ul><h1 id="双向channel和单向channel"><a href="#双向channel和单向channel" class="headerlink" title="双向channel和单向channel"></a>双向channel和单向channel</h1><p>一般情况下，我们定义的channel都是双向的，但是当我们想要对channel的数据流向做一些控制的时候，就会去定义单向的channel</p><ul><li><p>双向channel</p><p>默认情况下定义的信道都是双向的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>pipline := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;准备发送数据100：&quot;</span>)<br>pipline &lt;- <span class="hljs-number">100</span><br>&#125;()<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>number := &lt;-pipline<br>fmt.Printf(<span class="hljs-string">&quot;接收到的数据是%d&quot;</span>, number)<br>&#125;()<br>time.Sleep(time.Second)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>单向channel</p><ul><li><p>只读channel</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> pipline = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">type</span> Receiver = &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span><span class="hljs-comment">// 定义类型别名</span><br><span class="hljs-keyword">var</span> receiver Receiver = pipline<br></code></pre></td></tr></table></figure></li><li><p>只写channel</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> pipline = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">type</span> Sender = <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span><br>ver sender Sender = pipline<br></code></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">// 定义只读channel</span><br><span class="hljs-keyword">type</span> Receiver = &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span><br><br><span class="hljs-comment">// 定义只写channel</span><br><span class="hljs-keyword">type</span> Sender = <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>pipline := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> sender Sender = pipline<br>fmt.Println(<span class="hljs-string">&quot;准备发送数据：100&quot;</span>)<br>sender &lt;- <span class="hljs-number">100</span><br>&#125;()<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> receiver Receiver = pipline<br>num := &lt;-receiver<br>fmt.Printf(<span class="hljs-string">&quot;准备接收数据：%d&quot;</span>, num)<br>&#125;()<br><br>time.Sleep(time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="遍历channel"><a href="#遍历channel" class="headerlink" title="遍历channel"></a>遍历channel</h1><p>可以使用<code>for range</code>进行遍历，前提是确保信道处于关闭状态，否则循环会阻塞：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fibonacci</span><span class="hljs-params">(mychan <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>n := <span class="hljs-built_in">cap</span>(mychan)<br><br>x, y := <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>mychan &lt;- x<br>x, y = y, x+y<br>&#125;<br><span class="hljs-comment">// close channel</span><br><span class="hljs-built_in">close</span>(mychan)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>pipline := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br><br><span class="hljs-keyword">go</span> fibonacci(pipline)<br><br><span class="hljs-keyword">for</span> k := <span class="hljs-keyword">range</span> pipline &#123;<br>fmt.Println(k)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="用channel来做锁"><a href="#用channel来做锁" class="headerlink" title="用channel来做锁"></a>用channel来做锁</h1><p>利用阻塞程序的性质可以用来当程序的锁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">// x = x + 1不是原子操作</span><br><span class="hljs-comment">// 应该避免多个协程对其进行操作</span><br><br><span class="hljs-comment">// 使用cap为1的channel能够达到锁的操作</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>, x *<span class="hljs-type">int</span>)</span></span> &#123;<br>ch &lt;- <span class="hljs-literal">true</span><br>*x = *x + <span class="hljs-number">1</span><br>&lt;-ch<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 注意要设置cap为1的channel</span><br>pipline := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>, <span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">var</span> x <span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;<br><span class="hljs-keyword">go</span> increment(pipline, &amp;x)<br>&#125;<br><span class="hljs-comment">// 确保channel正常执行完</span><br>time.Sleep(time.Second)<br>fmt.Println(<span class="hljs-string">&quot;x的值为&quot;</span>, x)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果不加锁的话，输出就会小于1000</p><h1 id="channel传递是深拷贝吗？"><a href="#channel传递是深拷贝吗？" class="headerlink" title="channel传递是深拷贝吗？"></a>channel传递是深拷贝吗？</h1><p>在Go中，数据结构可以分为：</p><ul><li>值类型：int，string，float，bool，array，struct</li><li>引用类型：slice，map</li></ul><p><strong>如果传入的类型是值类型，就是浅拷贝；如果是引用类型，就是深拷贝</strong></p><blockquote><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul><li>关闭一个为初始化的channel会panic</li><li>重复关闭channel会panic</li><li>向关闭的channel发送消息会panic</li><li>close后的channel中读取消息不会堵塞，并且会返回一个false的值来表示关闭状态</li><li>close channel会产生广播机制</li><li>channel是线程安全的</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>go基础回顾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go协程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go协程--goroutine</title>
    <link href="/2022/12/19/go%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/go%E5%8D%8F%E7%A8%8B-goroutine/"/>
    <url>/2022/12/19/go%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/go%E5%8D%8F%E7%A8%8B-goroutine/</url>
    
    <content type="html"><![CDATA[<h1 id="协程的初步使用"><a href="#协程的初步使用" class="headerlink" title="协程的初步使用"></a>协程的初步使用</h1><p><em><strong>协程是轻量级的线程</strong></em></p><p>一个Go程序的入口是main函数，main函数最先运行，其本身也就是一个<code>goroutine</code>，我们称之为<code>main goroutine</code></p><p>在main中才能使用<code>go + func()</code>的方法来启动新的协程</p><p>main函数（主线程）执行完成后，这个线程也就结束了，main里面的所有协程也就会被强制终止</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><br>        <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mytest</span><span class="hljs-params">()</span></span> &#123;<br>  fmt.Println(<span class="hljs-string">&quot;hello, go&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-comment">// 启动一个协程</span><br>  <span class="hljs-keyword">go</span> mytest()<br>  fmt.Println(<span class="hljs-string">&quot;hello, world&quot;</span>)<br>  <span class="hljs-comment">// 不推荐的方式来阻塞协程</span><br>  time.Sleep(time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果不去阻塞的话，main里面的协程就会因为main函数执行后立刻结束导致其不会运行</p><h1 id="多个协程"><a href="#多个协程" class="headerlink" title="多个协程"></a>多个协程</h1><p>可以通过启动多个协程，实现并发的效果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mytest</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;In goroutine %s\n&quot;</span>, name)<br><span class="hljs-comment">// 避免第一个协程执行过快，观察不到并发的效果</span><br>time.Sleep(<span class="hljs-number">10</span> * time.Millisecond)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">go</span> mytest(<span class="hljs-string">&quot;协程1号&quot;</span>)<br><span class="hljs-keyword">go</span> mytest(<span class="hljs-string">&quot;协程2号&quot;</span>)<br>time.Sleep(time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go">In goroutine 协程<span class="hljs-number">1</span>号<br>In goroutine 协程<span class="hljs-number">2</span>号<br>In goroutine 协程<span class="hljs-number">2</span>号<br>In goroutine 协程<span class="hljs-number">1</span>号<br>In goroutine 协程<span class="hljs-number">2</span>号<br>In goroutine 协程<span class="hljs-number">1</span>号<br>In goroutine 协程<span class="hljs-number">1</span>号<br>In goroutine 协程<span class="hljs-number">2</span>号<br>In goroutine 协程<span class="hljs-number">2</span>号<br>In goroutine 协程<span class="hljs-number">1</span>号<br>In goroutine 协程<span class="hljs-number">1</span>号<br>In goroutine 协程<span class="hljs-number">2</span>号<br>In goroutine 协程<span class="hljs-number">2</span>号<br>In goroutine 协程<span class="hljs-number">1</span>号<br>In goroutine 协程<span class="hljs-number">1</span>号<br>In goroutine 协程<span class="hljs-number">2</span>号<br>In goroutine 协程<span class="hljs-number">1</span>号<br>In goroutine 协程<span class="hljs-number">2</span>号<br>In goroutine 协程<span class="hljs-number">2</span>号<br>In goroutine 协程<span class="hljs-number">1</span>号<br></code></pre></td></tr></table></figure><p>能够看到，<strong>两个协程就像两个线程一样</strong>，并发执行</p><p><code>goroutine</code>正是Go语言强大的并发特性的体现</p>]]></content>
    
    
    <categories>
      
      <category>go基础回顾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go协程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python--视频下载及转换</title>
    <link href="/2022/12/15/Python-%E8%A7%86%E9%A2%91%E4%B8%8B%E8%BD%BD%E5%8F%8A%E8%BD%AC%E6%8D%A2/"/>
    <url>/2022/12/15/Python-%E8%A7%86%E9%A2%91%E4%B8%8B%E8%BD%BD%E5%8F%8A%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="视频抓取下载"><a href="#视频抓取下载" class="headerlink" title="视频抓取下载"></a>视频抓取下载</h1><p><a href="https://you-get.org/#supported-sites">支持网站&#x2F;资源类型</a></p><h2 id="you-get"><a href="#you-get" class="headerlink" title="you-get"></a>you-get</h2><p>通过<code>pip3 install you-get</code>将依赖下载到本地</p><p>you-get是一个小型的命令行工具，可以从网络中获取视频&#x2F;音频&#x2F;图像</p><h3 id="下载视频"><a href="#下载视频" class="headerlink" title="下载视频"></a>下载视频</h3><p>通过<code>you-get [url]</code>的命令可以将视频&#x2F;音频&#x2F;图像下载到当前命令行所在的目录</p><p>而<code>you-get -i [url]</code>，加上<code>-i</code>之后就可以查看所有能可用的质量和格式</p><h3 id="设置下载的路径"><a href="#设置下载的路径" class="headerlink" title="设置下载的路径"></a>设置下载的路径</h3><p>使用<code>-o</code>设置下载的目录</p><p>使用<code>-0</code>设置下载的文件名</p><h3 id="鉴权-x2F-视频"><a href="#鉴权-x2F-视频" class="headerlink" title="鉴权&#x2F;视频"></a>鉴权&#x2F;视频</h3><p>通过<code>-c</code>提供浏览器的Cookie确保能获取视频</p><h3 id="拉取列表"><a href="#拉取列表" class="headerlink" title="拉取列表"></a>拉取列表</h3><p>使用<code>-u</code>查看所有能下载的url</p><h3 id="Google搜索下载"><a href="#Google搜索下载" class="headerlink" title="Google搜索下载"></a>Google搜索下载</h3><p>可以使用<code>you-get [关键字]</code>在google浏览器上进行搜索然后下载，当然这种方式很随意</p><h1 id="视频转音频"><a href="#视频转音频" class="headerlink" title="视频转音频"></a>视频转音频</h1><h2 id="os-walk"><a href="#os-walk" class="headerlink" title="os.walk()"></a><code>os.walk()</code></h2><p>使用<code>os.walk()</code>来深度遍历文件</p><p>在python中，<code>os.walk()</code>调用方法为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">walk</span>(<span class="hljs-params">top, topdown=<span class="hljs-literal">True</span>, onerror=<span class="hljs-literal">None</span>, followlinks=<span class="hljs-literal">False</span></span>):<br></code></pre></td></tr></table></figure><ul><li>top也就是文件的根目录</li><li>topdown为True时，由外向里遍历，否则由里向外</li><li>followlinks是快捷方式所在的原目录</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">from</span> pydub <span class="hljs-keyword">import</span> AudioSegment<br><br>wenjianjia = []<br>path = <span class="hljs-string">&quot;/Users/zhanghaoyu/Desktop/video&quot;</span>         <span class="hljs-comment"># input(&#x27;请输入要转码的父文件夹路径：&#x27;)</span><br><span class="hljs-keyword">for</span> root, dirs, files <span class="hljs-keyword">in</span> os.walk(path):         <span class="hljs-comment"># 文件夹目录、目录列表、文件列表</span><br>    wenjianjia.append(root)<br>wjj = wenjianjia<br><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">dir</span> <span class="hljs-keyword">in</span> wjj:<br>    video_dir = <span class="hljs-built_in">dir</span><br>    extension_list = (<span class="hljs-string">&#x27;*.mp4&#x27;</span>, <span class="hljs-string">&#x27;*.flv&#x27;</span>)<br>    i = <span class="hljs-number">1</span><br><br>    os.chdir(video_dir)     <span class="hljs-comment"># 改变当前路径</span><br>    <span class="hljs-keyword">for</span> extension <span class="hljs-keyword">in</span> extension_list:<br>        <span class="hljs-keyword">for</span> video <span class="hljs-keyword">in</span> glob.glob(extension):      <span class="hljs-comment"># 匹配后缀</span><br>            mp3_filename = os.path.splitext(os.path.basename(video))[<span class="hljs-number">0</span>] + <span class="hljs-string">&#x27;.mp3&#x27;</span><br>            AudioSegment.from_file(video).export(mp3_filename, <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;mp3&#x27;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;已转码&#x27;</span>, <span class="hljs-built_in">str</span>(i), <span class="hljs-string">&#x27;个视频！&#x27;</span>)<br>            i += <span class="hljs-number">1</span><br>            os.remove(video)        <span class="hljs-comment"># 删除原来的视频</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go基础回顾--方法</title>
    <link href="/2022/12/14/go%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/go%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE-%E6%96%B9%E6%B3%95/"/>
    <url>/2022/12/14/go%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/go%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE-%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Go方法一般形式"><a href="#Go方法一般形式" class="headerlink" title="Go方法一般形式"></a>Go方法一般形式</h1><p><img src="https://static001.geekbang.org/resource/image/7b/dd/7b3a2b6b620a27cca9b92bf612e66ddd.jpg?wh=2096x990" alt="方法一般形式"></p><p>一般形式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T或T)</span></span> MethodName(参数列表) (返回值列表) &#123;<br>  <span class="hljs-comment">// 方法体</span><br>&#125;<br></code></pre></td></tr></table></figure><p>和函数相比，Go方法中多了一个<code>receiver</code>参数，<strong>这个<code>receiver</code>参数也是方法与类型之间的纽带，也是方法与函数的最大不同</strong></p><h1 id="receiver参数"><a href="#receiver参数" class="headerlink" title="receiver参数"></a><code>receiver</code>参数</h1><p>Go中的方法必须是归属于一个类型的，而<code>receiver</code>参数的类型就是这个方法归属的类型，也就是这个类型的一个方法</p><h2 id="基类型"><a href="#基类型" class="headerlink" title="基类型"></a>基类型</h2><p><code>receiver</code>参数的类型为<code>*T</code>或者<code>T</code>，基类型都是<code>T</code></p><p><strong>参数的基类型本身不能为指针类型或者接口类型</strong></p><p><em><strong>每个方法中只能支持一个<code>receiver</code>参数</strong></em></p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p><strong><code>receiver</code>参数、函数&#x2F;方法参数、返回值变量对应的作用域范围，都是函数&#x2F;方法提对应的显式代码块</strong></p><p>这样的话，<code>receiver</code>参数名和方法列表中的形参名、以及具名返回值的变量名存在冲突，<strong>具有唯一性</strong></p><p><strong>如果没有用到<code>receiver</code>参数，那么参数名可以省略</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(T)</span></span> M(t <span class="hljs-type">string</span>) &#123;<br>  ... ...<br>&#125;<br></code></pre></td></tr></table></figure><p>方法声明要与<code>receiver</code>参数的基类型声明放在同一个包内：</p><ul><li>不能为原生类型（<code>int</code>、<code>map</code>、<code>float128</code>等）添加方法</li><li>不能跨越Go包为其他包的类型声明新方法</li></ul><h1 id="Go方法本质"><a href="#Go方法本质" class="headerlink" title="Go方法本质"></a>Go方法本质</h1><p>类比C++，C++中的对象在调用方法时，编译器会自动传入指向对象自身的this指针作为方法的第一个参数</p><p>Go方法中的原理也是类似的，<strong>是将<code>receiver</code>参数以第一个参数的身份并入到方法的参数列表中</strong>，那么这样就可以将方法等价成函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>  a <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// 方法一</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t T)</span></span> Get() <span class="hljs-type">int</span> &#123;<br>  <span class="hljs-keyword">return</span> t.a<br>&#125;<br><span class="hljs-comment">// 函数一</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Get</span><span class="hljs-params">(t T)</span></span> <span class="hljs-type">int</span> &#123;<br>  <span class="hljs-keyword">return</span> t.a<br>&#125;<br><br><span class="hljs-comment">// 方法二</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span></span> Set(a <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>  t.a = a<br>  <span class="hljs-keyword">return</span> t.a<br>&#125;<br><span class="hljs-comment">// 函数二</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Set</span><span class="hljs-params">(t *T, a <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>  t.a = a<br>  <span class="hljs-keyword">return</span> t.a<br>&#125;<br></code></pre></td></tr></table></figure><p>这种转换在Go中会自动完成</p><h2 id="方法表达式"><a href="#方法表达式" class="headerlink" title="方法表达式"></a>方法表达式</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> t T<br>t.Get()<br>(&amp;t).Set(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">// 等价替换</span><br><span class="hljs-keyword">var</span> t T<br>T.Get(t)<br>(*T).Set(&amp;t, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>下面这种直接以类型名T调用方法的表达方式，被称为<code>Method Expression</code></p><p>通过这种方式，类型T只能调用T的方法集合中的方法，而<code>*T</code>也只能调用<code>*T</code>的方法集合中的方法</p><p>也就是说，Go语言中的方法的本质<strong>就是一个以方法的<code>receiver</code>参数作为第一个参数的普通函数</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">var</span> t T<br>  f1 := (*T).Set<span class="hljs-comment">// f1的类型，也就是*T类型的Set方法的类型</span><br>  f2 := T.Get<br>  <br>  f1(&amp;t, <span class="hljs-number">3</span>)<br>  fmt.Println(f2(t))<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>go方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go基础回顾--函数</title>
    <link href="/2022/12/14/go%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/go%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE-%E5%87%BD%E6%95%B0/"/>
    <url>/2022/12/14/go%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/go%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE-%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h1><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h93d90w4j7j31hc0ldt9v.jpg" alt="普通go函数声明"></p><p>可以看成是在声明一个类型为函数类型的变量</p><p>也就是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> Fprintf = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(参数列表)</span></span> (返回值列表) &#123;<br>  <span class="hljs-comment">// 函数体</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中，参数列表和返回值列表可以看成是<strong>函数签名</strong>，函数类型可以看成是由<strong>func关键字</strong>和<strong>函数签名</strong>组合而成</p><p>在表示函数类型时，会省略函数签名中的变量名，只看类型，所以每个函数声明定义的函数，仅仅是对应对函数类型的一个实例</p><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p><code>f := func()&#123;&#125;</code>，像这样的一个函数，叫<strong>函数字面值</strong>，也就是<strong>匿名函数</strong>，是一个没有函数名的函数声明</p><h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><p>在go语言中，函数的参数传递采用的是<strong>值传递</strong>的方式，也就是将实际参数在内存中的表示copy一份到形式参数中</p><p>对于整型、数组、结构体类型，它们的内存表示就是它们自身的数据内容，值拷贝就是拷贝的它们自身</p><p>而像string、切片、map类型，它们的内存表示是它们数据内容的描述符，值传递拷贝的内容也是它们的描述符，这种被称为<strong>浅拷贝</strong></p><blockquote><p>例外</p></blockquote><ul><li>接口类型</li><li>变长参数</li></ul><p><em>这种时候，简单的值传递不能够满足要求了，Go编译器就会介入</em>：</p><p>对于接口类型的形参，Go编译器会把传递的实参赋值给对应的接口类型形参</p><p>对于变长参数的形参，Go编译器会将零个或者多个实参按一定的形式转换为对应的变长形参</p><h2 id="变长形参"><a href="#变长形参" class="headerlink" title="变长形参"></a>变长形参</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myAppend</span><span class="hljs-params">(sl []<span class="hljs-type">int</span>, elems ...<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<span class="hljs-comment">// 声明一个变长形参</span><br>  <span class="hljs-comment">// 函数体</span><br>  ... ...<br>  sl = <span class="hljs-built_in">append</span>(sl, elems...)<span class="hljs-comment">// 追加</span><br>  ... ...<br>&#125;<br></code></pre></td></tr></table></figure><p>变长参数是通过<strong>切片</strong>来实现的</p><h1 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h1><ul><li>支持多返回值</li><li>在返回值多的情况下，可以使用具名返回值</li><li>一般情况下使用普通的非具名返回值的形式</li></ul><h1 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h1><ul><li>函数可以存储在变量中</li><li>支持在函数内创建函数并通过返回值返回</li><li>函数可以作为参数传入函数</li><li>函数拥有自己的类型</li></ul><h2 id="函数可以存储在变量中"><a href="#函数可以存储在变量中" class="headerlink" title="函数可以存储在变量中"></a>函数可以存储在变量中</h2><p>可以将一个匿名函数赋值给一个变量，通过这个变量去调用这个函数，也可以简单理解为变量名就是函数名</p><h2 id="支持在函数内创建并通过返回值返回"><a href="#支持在函数内创建并通过返回值返回" class="headerlink" title="支持在函数内创建并通过返回值返回"></a>支持在函数内创建并通过返回值返回</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setup</span><span class="hljs-params">(task <span class="hljs-type">string</span>)</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>  fmt.Println(<span class="hljs-string">&quot;do some setup stuff for&quot;</span>, task)<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;do some teardown stuff for&quot;</span>, task)<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  teardown := setup(<span class="hljs-string">&quot;demo&quot;</span>)<br>  <span class="hljs-keyword">defer</span> teardown()<br>  fmt.Println(<span class="hljs-string">&quot;do some bussiness stuff&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 输出结果：</span><br><span class="hljs-comment">// Do some setup stuff for demo</span><br><span class="hljs-comment">// Do some business stuff.</span><br><span class="hljs-comment">// Do some teardown stuff for demo</span><br></code></pre></td></tr></table></figure><p>这个demo模拟执行了一些重要逻辑之前的上下文setup，以及上下文的teardown，常用于单元测试中包裹用例执行</p><p>setup函数是一个闭包函数，对于闭包而言：</p><ul><li>闭包其本质上是一个匿名函数或者叫函数字面值</li><li>可以引用它的包裹函数，变量在包裹函数和匿名函数之间共享，只要闭包可以访问，共享的变量就会继续存在</li></ul><h2 id="作为参数传入函数"><a href="#作为参数传入函数" class="headerlink" title="作为参数传入函数"></a>作为参数传入函数</h2><p>可以在函数中作为函数的参数传入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">time.AfterFunc(time.second*<span class="hljs-number">2</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;timer fired&quot;</span>)&#125;)<br></code></pre></td></tr></table></figure><h2 id="拥有自己的类型"><a href="#拥有自己的类型" class="headerlink" title="拥有自己的类型"></a>拥有自己的类型</h2><p>像整型、数组、结构体等类型一样，每个函数声明定义的函数对应的是函数类型的一个实例，可以<strong>基于函数类型来自定义类型</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> HandlerFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ResponseWriter, *Request)</span></span><br><br><span class="hljs-keyword">type</span> visitFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ast.Node)</span></span> ast.Visitor<br></code></pre></td></tr></table></figure><h1 id="函数运用"><a href="#函数运用" class="headerlink" title="函数运用"></a>函数运用</h1><h2 id="显式转型"><a href="#显式转型" class="headerlink" title="显式转型"></a>显式转型</h2><p>函数本身是一个类型，可以进行其他类型所有可以进行的操作，比如<strong>显式转型</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greeting</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>  fmt.Fprintf(w, <span class="hljs-string">&quot;Welcome, Gopher!\n&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, http.HandlerFunc(greeting))<br>&#125;<br></code></pre></td></tr></table></figure><p>函数<code>ListenAndServe</code>会把来自客户端的http请求，交给它的第二个参数<code>handler</code>处理，参数<code>handler</code>的类型为<code>http.Handler</code>，是一个自定义的接口类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Handler <span class="hljs-keyword">interface</span> &#123;<br>  ServerHTTP(ResponseWriter, *Request)<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>Handler</code>这个接口中，只有一个方法<code>ServerHTTP</code>，它的函数类型为<code>func(http.ResponseWriter, *http.Request)</code>，这个类型和我们自定义的<code>greeting</code>函数的类型一样，但是我们不能直接将<code>greeting</code>作为参数值传入，<strong>因为函数<code>greeting</code>还没有实现接口<code>Handler</code>的方法，无法将它赋值给<code>Handler</code>类型的参数</strong>，我们是通过将<code>http.HandlerFunc(greeting)</code>作为了第二个参数传进去：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> HandlerFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ResponseWriter, *Request)</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f HandlerFunc)</span></span> ServerHTTP(w ResponseWriter, r *Request) &#123;<br>  f(w, r)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>HandlerFunc</code>是基于函数类型定义的一个新类型，底层的函数类型为<code>func(ResponseWriter, *Request)</code>，然后为这个类型定义了一个方法，实现了<code>Handler</code>接口</p><p>所以，<code>http.HandlerFunc(greeting)</code>是将原函数显示转换为另一个函数，另一个函数实现了接口，满足第二个参数的要求</p><h2 id="闭包简化函数调用"><a href="#闭包简化函数调用" class="headerlink" title="闭包简化函数调用"></a>闭包简化函数调用</h2><p>应用闭包，有时可以将高频出现、重复的东西简化掉</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">time</span><span class="hljs-params">(x <span class="hljs-type">int</span>, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>  <span class="hljs-keyword">return</span> x * y<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partialTimes</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> time(x, y)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个过程的逻辑就相当于：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">timesTwo = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>  <span class="hljs-keyword">return</span> times(<span class="hljs-number">2</span>, y)<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，就不用每次都将2传递进去了</p>]]></content>
    
    
    <categories>
      
      <category>go基础回顾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go基础回顾（七）--switch语句</title>
    <link href="/2022/12/14/go%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/go%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE%EF%BC%88%E4%B8%83%EF%BC%89-switch%E8%AF%AD%E5%8F%A5/"/>
    <url>/2022/12/14/go%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/go%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE%EF%BC%88%E4%B8%83%EF%BC%89-switch%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<blockquote><p> 除了if语句外，go还支持一种更适合用多路分支执行到分支控制结构</p></blockquote><h1 id="一般形式"><a href="#一般形式" class="headerlink" title="一般形式"></a>一般形式</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> initStmt; expr &#123;<br>  <span class="hljs-keyword">case</span> expr1:<br>  <span class="hljs-comment">// 执行分支1</span><br>  <span class="hljs-keyword">case</span> expr2:<br>  <span class="hljs-comment">// 执行分支2</span><br>  <span class="hljs-keyword">case</span> expr3_1, expr3_2, expr3_3:<br>  <span class="hljs-comment">// 执行分支3</span><br>  <span class="hljs-keyword">case</span> expr4:<br>  <span class="hljs-comment">// 执行分支4</span><br>  <span class="hljs-keyword">case</span> expr5:<br>  <span class="hljs-comment">// 执行分支5</span><br>  dafault:<br>  <span class="hljs-comment">// 执行默认分支</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>initStmt</code>表示的是声明一些短变量在<code>switch</code>语句中使用，是临时变量</li><li><code>expr</code>是一个表达式，<code>switch</code>语句会将<code>expr</code>的结果与下面的<code>case</code>进行比较匹配</li><li>匹配成功就执行case后面的语句，执行完成后默认为退出整个<code>switch</code>语句，<code>default</code>语句是在所有<code>case</code>都不满足的时候才去执行的</li></ul><h1 id="灵活性"><a href="#灵活性" class="headerlink" title="灵活性"></a>灵活性</h1><ul><li><code>switch</code>语句各表达式的求值结果可以为各种类型值，只要它的类型支持比较就行</li><li>当要比较的类型是<code>bool</code>类型时，如果<code>expr</code>的求值结果为<code>true</code>，那么可以将expr省略：<code>switch initStmt; &#123;...&#125;</code>或<code>switch &#123;...&#125;</code></li><li><code>switch</code>支持声明临时变量也就是<code>initStmt</code></li><li><code>case</code>语句支持表达式列表：<code>case expr2_1, expr2_2, expr2_3:</code></li><li>取消默认执行下一个case代码逻辑的语义：**如果想要执行后面的语句，可以在<code>case</code>语句中的代码块最后加上关键字<code>fallthrough</code></li></ul><p><em><strong>注意 ⚠️</strong></em></p><p><strong>当使用了<code>fallthrough</code>关键字，<code>case</code>语句不会对表达式进行求值操作，而是直接执行case对应的代码分支，最后一个分支不能使用<code>fallthrough</code>关键字</strong></p><h1 id="type-switch"><a href="#type-switch" class="headerlink" title="type switch"></a><code>type switch</code></h1><h2 id="进行动态类型比较"><a href="#进行动态类型比较" class="headerlink" title="进行动态类型比较"></a>进行动态类型比较</h2><p>Go语言的<code>switch</code>语句支持求值结果为类型信息的表达式：<code>switch x.(type)&#123;...&#125;</code></p><ul><li>x类型必须是一个<strong>接口类型变量</strong></li><li>表达式的求值结果是这个接口类型变量对应的动态类型</li></ul><p>以<code>var x interface&#123;&#125; = 14</code>为例，x是一个接口类型变量，静态类型为<code>interface&#123;&#125;</code>，由于将整型值14赋值给了x，则x的动态类型为<code>int</code>类型</p><p><code>type switch</code>是将动态类型进行比较匹配</p><h2 id="获取动态类型的值进行比较"><a href="#获取动态类型的值进行比较" class="headerlink" title="获取动态类型的值进行比较"></a>获取动态类型的值进行比较</h2><p><code>v := x.(type)</code>，这个表达式并不是将x的动态类型给了v，而是将x的动态类型对应的值赋给了v，<strong>v存储的是变量x的动态类型对应的值信息</strong></p><p><strong>接口类型和case后面的类型对应的接口类型要一样</strong></p><h1 id="break"><a href="#break" class="headerlink" title="break"></a>break</h1><p>不带label的break语句中断执行并跳出的，是同一个函数内break语句所在的最内层的for、switch或select，如果在<code>case</code>分支语句中加了<code>break</code>，那么就只能跳出<code>switch</code>语句，不能跳出外层的<code>for</code>循环等控制结构，只能去定义一个label。</p>]]></content>
    
    
    <categories>
      
      <category>go基础回顾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go控制结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go基础回顾（六）--if控制语句</title>
    <link href="/2022/12/14/go%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/go%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE%EF%BC%88%E5%85%AD%EF%BC%89-if%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/"/>
    <url>/2022/12/14/go%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/go%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE%EF%BC%88%E5%85%AD%EF%BC%89-if%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h1><ul><li>单分支结构</li><li>二分支结构</li><li>多分支结构</li></ul><h2 id="单分支结构"><a href="#单分支结构" class="headerlink" title="单分支结构"></a>单分支结构</h2><p>Go语言中if语句是分支控制结构，能够根据<strong>布尔表达式的值</strong>，在两个分支中选择一个执行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> bookean_expression &#123;<br>  <span class="hljs-comment">// 新分支</span><br>&#125;<br><br><span class="hljs-comment">// 原分支</span><br></code></pre></td></tr></table></figure><p>从流程图上来看就是：</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h933kml2xqj31480qmgmj.jpg" alt="单分支结构"></p><p>当布尔表达式的结果为true的时候，就会进入新分支运行，否则就会到原分支。</p><h2 id="二分支结构"><a href="#二分支结构" class="headerlink" title="二分支结构"></a>二分支结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> boolean_expression &#123;<br>  <span class="hljs-comment">// 分支1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 分支2</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多分支结构"><a href="#多分支结构" class="headerlink" title="多分支结构"></a>多分支结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> boolean_expression1 &#123;<br>  <span class="hljs-comment">// 分支1</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> boolean_expression2 &#123;<br>  <span class="hljs-comment">// 分支2</span><br>  <br>... ...<br>  <br>  <br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> boolean_expressionN &#123;<br>  <span class="hljs-comment">// 分支N</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 分支N+1</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><ul><li>if语句分支代码块的左大括号与if关键字在同一行上</li><li>布尔表达式整体不用像C语言那样被括号包裹</li><li>如果判断的条件比较多，可以用多个逻辑操作符连接起多个条件判断表达式</li></ul><h1 id="操作符优先级"><a href="#操作符优先级" class="headerlink" title="操作符优先级"></a>操作符优先级</h1><ul><li>逻辑操作符有<code>&amp;&amp;</code>（与）、<code>||</code>（或）、<code>!</code>（非）</li></ul><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h933ksr7h5j313p0g1ab7.jpg" alt="操作符优先级"></p><p>一般会使用<code>()</code>包括来使运算更直观，降低开发人员的心智负担。</p><h1 id="支持声明if语句的自用变量"><a href="#支持声明if语句的自用变量" class="headerlink" title="支持声明if语句的自用变量"></a>支持声明if语句的自用变量</h1><p>在Go语言中，可以在if语句中布尔表达式之前，进行变量的声明，这样的变量即<strong>if语句的自用变量</strong>，只能在if语句的代码块范围内使用，<em><strong>作用域起始于它声明所在的代码块，并且一直可扩展至嵌入到这个代码块的所有内层代码块中，在运用时一定要注意变量遮蔽问题</strong></em></p><h1 id="if语句的“快乐路径”原则"><a href="#if语句的“快乐路径”原则" class="headerlink" title="if语句的“快乐路径”原则"></a>if语句的“快乐路径”原则</h1><ul><li>仅使用单分支控制结构</li><li>当布尔表达式求值为false时，在单分支中快速返回</li><li>正常逻辑在代码布局上始终“靠左”，可以一眼看到函数正常逻辑的全貌</li><li>函数执行到最后一行代表一种成功状态</li></ul>]]></content>
    
    
    <categories>
      
      <category>go基础回顾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go控制结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go基础数据类型(五)--结构体类型</title>
    <link href="/2022/12/12/go%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/go%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <url>/2022/12/12/go%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/go%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="如何自定义一个新类型"><a href="#如何自定义一个新类型" class="headerlink" title="如何自定义一个新类型"></a>如何自定义一个新类型</h1><ul><li>类型定义</li><li>使用类型别名</li></ul><h2 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h2><h3 id="基于已有类型定义新类型"><a href="#基于已有类型定义新类型" class="headerlink" title="基于已有类型定义新类型"></a>基于已有类型定义新类型</h3><p>形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T s <span class="hljs-comment">// 定义一个新类型T</span><br></code></pre></td></tr></table></figure><p>s可以是任何一个已定义的类型，包括go原生类型，或者是其他已经定义好的类型，说白了也就是类型的嵌套（套娃）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T1 <span class="hljs-type">int</span><br><span class="hljs-keyword">type</span> T2 T1<br></code></pre></td></tr></table></figure><h4 id="底层类型"><a href="#底层类型" class="headerlink" title="底层类型"></a>底层类型</h4><p>如果一个类型是基于某个go的原生类型定义的新类型，那么这个go原生类型就是它的底层类型，对于基于新定义的类型定义的类型，其底层类型要剖析到最底层</p><p><strong>底层类型用来判断两个类型本质上是否相同，如果本质上是相同的，那么它们的变量可以通过显式转型进行相互赋值，而不同的就不行</strong></p><h3 id="基于类型字面值定义新类型"><a href="#基于类型字面值定义新类型" class="headerlink" title="基于类型字面值定义新类型"></a>基于类型字面值定义新类型</h3><p>这种方法多用于定义<strong>复合类型</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> M <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span><br><span class="hljs-keyword">type</span> S []<span class="hljs-type">string</span><br></code></pre></td></tr></table></figure><p>就像一次性声明多个变量一样，定义新类型也可以一次性定义多个：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> (<br>T1 <span class="hljs-type">int</span><br>  T2 T1<br>  T3 []<span class="hljs-type">string</span><br>)<br></code></pre></td></tr></table></figure><h2 id="使用类型别名"><a href="#使用类型别名" class="headerlink" title="使用类型别名"></a>使用类型别名</h2><p>这种类型定义方式通常用在项目的渐进式重构中，还有对已有包的二次封装方面：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T = s<span class="hljs-comment">// type alias</span><br></code></pre></td></tr></table></figure><p>与直接进行类型定义相比，这种定义方式多了一个<code>=</code>，也就是让新类型T和原类型S完全等价，即<strong>同一个类型但是有两个名字</strong></p><h1 id="如何定义一个结构体类型"><a href="#如何定义一个结构体类型" class="headerlink" title="如何定义一个结构体类型"></a>如何定义一个结构体类型</h1><h2 id="通过类型字面值来定义"><a href="#通过类型字面值来定义" class="headerlink" title="通过类型字面值来定义"></a>通过类型字面值来定义</h2><p>结构体是复合数据类型，所以我们可以通过类型字面值进行定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>  Field1 T1<br>  Field2 T2<br>  Field3 T3<br>  ... ...<br>  Fieldn Tn<br>&#125;<br></code></pre></td></tr></table></figure><p>有了结构体之后，我们就可以对真实世界的某些东西进行抽象了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> book<br><br><span class="hljs-keyword">type</span> Book <span class="hljs-keyword">struct</span> &#123;<br>  Title <span class="hljs-type">string</span><span class="hljs-comment">// 书名</span><br>  Pages <span class="hljs-type">int</span><span class="hljs-comment">// 书的页数</span><br>  Indexes <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><span class="hljs-comment">// 书的索引</span><br>&#125;<br></code></pre></td></tr></table></figure><p>你会发现，Book和它的各个字段中都用了首字母大写的名字，原因就是：<strong>Go用标识符的名称的首字母大小写来判定这个标识符是否为导出标识符，如果是，其它包导入了这个包的话，就可以直接引用类型名和其字段名</strong></p><h2 id="定义一个空结构体"><a href="#定义一个空结构体" class="headerlink" title="定义一个空结构体"></a>定义一个空结构体</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Empty <span class="hljs-keyword">struct</span>&#123;&#125;<span class="hljs-comment">// Empty是一个不包含任何字段的空结构体类型</span><br></code></pre></td></tr></table></figure><p><strong>空结构体类型变量的大小为0，也就是内存占用为0</strong>，即<strong>内存零开销</strong>，这种用法可以作为“事件”信息进行Goroutine之间的通信。</p><h2 id="使用其他结构体作为自定义结构体中字段的类型"><a href="#使用其他结构体作为自定义结构体中字段的类型" class="headerlink" title="使用其他结构体作为自定义结构体中字段的类型"></a>使用其他结构体作为自定义结构体中字段的类型</h2><h3 id="提供字段名进行定义"><a href="#提供字段名进行定义" class="headerlink" title="提供字段名进行定义"></a>提供字段名进行定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>  Name <span class="hljs-type">string</span><br>  Phone <span class="hljs-type">string</span><br>  Addr <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Book <span class="hljs-keyword">struct</span> &#123;<br>  Title <span class="hljs-type">string</span><br>  Author Person<br>  ... ...<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是结构体嵌套结构体</p><h3 id="无需提供字段名"><a href="#无需提供字段名" class="headerlink" title="无需提供字段名"></a>无需提供字段名</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Book <span class="hljs-keyword">struct</span> &#123;<br>  Title <span class="hljs-type">string</span><br>  Person<br>  ... ...<br>&#125;<br></code></pre></td></tr></table></figure><p>直接使用类型</p><p>这种方式定义的结构体字段，也就是<strong>嵌入字段（匿名字段）</strong>，可以直接将类型名看成是这个字段的名字，访问的话就是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> book Book<br><span class="hljs-comment">// 把类型名看成字段名</span><br>fmt.Println(book.Person.Phone)<br><span class="hljs-comment">// 直接访问</span><br>fmt.Println(book.Phone)<br></code></pre></td></tr></table></figure><h2 id="注意-⚠️"><a href="#注意-⚠️" class="headerlink" title="注意 ⚠️"></a>注意 ⚠️</h2><p>在结构体类型T的定义中不能不能包含类型为T的字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>  t T<br>  ... ... <br>&#125;<br><span class="hljs-comment">// 这种定义方式是错误的</span><br></code></pre></td></tr></table></figure><p><em><strong>Go不支持在结构体类型定义中嵌套自身</strong></em></p><p>但是，虽然不能放入自身去递归，<strong>可以放入拥有自身类型的指针类型、切片类型、map类型的字段</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>  t *T<br>  st []T<br>  m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]T<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Book <span class="hljs-keyword">struct</span> &#123;<br>  ...<br>&#125;<br><br><span class="hljs-keyword">var</span> book Book<br><br><span class="hljs-keyword">var</span> book = Book&#123;&#125;<br><br>book := Book&#123;&#125;<br></code></pre></td></tr></table></figure><p>结构体类型的变量通常都要被赋予适当的初始值后，才会有合理的意义</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><ul><li>零值初始化</li><li>使用复合字面值</li><li>使用特定的构造函数</li></ul><h2 id="零值初始化"><a href="#零值初始化" class="headerlink" title="零值初始化"></a>零值初始化</h2><p>零值初始化也就是<strong>使用结构体变量的默认值零值作为它的初始值</strong>，这种方法的好处就是不用显式赋值操作，一般不会用于显示世界的抽象中，但是也还是有用处的，比如互斥锁</p><h2 id="使用复合字面值"><a href="#使用复合字面值" class="headerlink" title="使用复合字面值"></a>使用复合字面值</h2><h3 id="按顺序依次给每个结构体字段进行赋值"><a href="#按顺序依次给每个结构体字段进行赋值" class="headerlink" title="按顺序依次给每个结构体字段进行赋值"></a>按顺序依次给每个结构体字段进行赋值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Book <span class="hljs-keyword">struct</span> &#123;<br>    Title <span class="hljs-type">string</span>              <span class="hljs-comment">// 书名</span><br>    Pages <span class="hljs-type">int</span>                 <span class="hljs-comment">// 书的页数</span><br>    Indexes <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>    <span class="hljs-comment">// 书的索引</span><br>&#125;<br><br><span class="hljs-keyword">var</span> book = Book&#123;<span class="hljs-string">&quot;The Go Programming Language&quot;</span>, <span class="hljs-number">700</span>, <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)&#125;<br></code></pre></td></tr></table></figure><p>但是这种方法不够灵活</p><p>而且一旦结构体中出现了非导出字段，就会报错了</p><h3 id="使用field-value形式的复合字面值"><a href="#使用field-value形式的复合字面值" class="headerlink" title="使用field: value形式的复合字面值"></a>使用<code>field: value</code>形式的复合字面值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> t = T&#123;<br>  F2: <span class="hljs-string">&quot;hello&quot;</span>,<br>  F1: <span class="hljs-number">11</span>,<br>  F4: <span class="hljs-number">14</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式不用关系顺序</p><p>而且在结构体采用类型零值时，一般也会用这种方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">t := T&#123;&#125;<br></code></pre></td></tr></table></figure><p>很少使用<code>new</code>函数来创建结构体变量的实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">tp := <span class="hljs-built_in">new</span>(T)<br></code></pre></td></tr></table></figure><h2 id="使用特定的构造函数"><a href="#使用特定的构造函数" class="headerlink" title="使用特定的构造函数"></a>使用特定的构造函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/time/sleep.go</span><br><span class="hljs-keyword">type</span> runtimeTimer <span class="hljs-keyword">struct</span> &#123;<br>    pp       <span class="hljs-type">uintptr</span><br>    when     <span class="hljs-type">int64</span><br>    period   <span class="hljs-type">int64</span><br>    f        <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">uintptr</span>)</span></span> <br>    arg      <span class="hljs-keyword">interface</span>&#123;&#125;<br>    seq      <span class="hljs-type">uintptr</span><br>    nextwhen <span class="hljs-type">int64</span><br>    status   <span class="hljs-type">uint32</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Timer <span class="hljs-keyword">struct</span> &#123;<br>    C &lt;-<span class="hljs-keyword">chan</span> Time<br>    r runtimeTimer<br>&#125;<br></code></pre></td></tr></table></figure><p>Timer结构体中包含一个非导出字段r，r的类型为另外一个结构体类型runtimeTimer，而且runtimeTimer结构体不是零值可用的，此时就没办法使用显式复合字面值的方式了，而Go提供了一个构造函数NewTimer：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// $GOROOT/src/time/sleep.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTimer</span><span class="hljs-params">(d Duration)</span></span> *Timer &#123;<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Time, <span class="hljs-number">1</span>)<br>    t := &amp;Timer&#123;<br>        C: c,<br>        r: runtimeTimer&#123;<br>            when: when(d),<br>            f:    sendTime,<br>            arg:  c,<br>        &#125;,<br>    &#125;<br>    startTimer(&amp;t.r)<br>    <span class="hljs-keyword">return</span> t<br>&#125;<br></code></pre></td></tr></table></figure><p>返回了一个可用状态的Timer类型指针实例</p><p>其他的构造函数大多复合这种模式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewT</span><span class="hljs-params">(field1, field2, ...)</span></span> *T &#123;<br>    ... ...<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>由于结构体在内存存储上，会采用内存对齐的方式，在设计结构体时，可以注意一下各个字段的顺序。</p>]]></content>
    
    
    <categories>
      
      <category>go基础回顾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go数据类型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go数据类型回顾（四）--map类型</title>
    <link href="/2022/12/12/go%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/go%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-map%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <url>/2022/12/12/go%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/go%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-map%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>在go中，map类型的表示为<code>map[key_type]value_type</code></p><p>map类型对<code>value</code>没有限制，但是对<code>key</code>，<strong>必须要保证<code>key</code>的唯一性，go语言中的<code>key</code>要支持<code>==</code>和<code>!=</code>两种运算符</strong></p><p>在go语言中，<em><strong>函数类型、map类型、切片类型只支持与<code>nil</code>进行比较，而不能和同类型的变量相互比较，map类型中<code>key</code>也不能是以上类型。</strong></em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s1 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">2</span>)<br>s2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">1</span>)<br><br>f1 := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;&#125;<br>f2 := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;&#125;<br><br>m1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br>m2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br><br>fmt.Println(s1 == <span class="hljs-literal">nil</span>)<br>fmt.Println(s1 == s2)<span class="hljs-comment">// 错误：invalid operation: s1 == s2 (slice can only be compared to nil)</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="声明和初始化"><a href="#声明和初始化" class="headerlink" title="声明和初始化"></a>声明和初始化</h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> <span class="hljs-comment">// 一个map[string]int类型的变量</span><br></code></pre></td></tr></table></figure><p>和切片类型一样，如果没有显式的对其赋值，其变量的默认值为<code>nil</code></p><p>但是，切片在这种基础上是可以利用<code>append</code>函数追加值的，而map类型不行</p><h2 id="显式初始化"><a href="#显式初始化" class="headerlink" title="显式初始化"></a>显式初始化</h2><ul><li>使用复合字面值初始化</li><li>使用<code>make</code>为map类型的变量进行显式初始化</li></ul><h3 id="复合字面值初始化"><a href="#复合字面值初始化" class="headerlink" title="复合字面值初始化"></a>复合字面值初始化</h3><p><code>m1 := map[int]string&#123;&#125;</code></p><p>m1变量没有任何键值对，但是其也不等同于<code>nil</code></p><p><strong>提醒：</strong>因为在声明的时候已经指明了key和value的类型，所以对key和value进行赋值的时候可以省略类型名称</p><h3 id="使用make为map类型变量进行显式初始化"><a href="#使用make为map类型变量进行显式初始化" class="headerlink" title="使用make为map类型变量进行显式初始化"></a>使用make为map类型变量进行显式初始化</h3><p>类比对切片的操作，使用make时：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">s1 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure><p>这样就开辟了一个int类型的初始长度为3、容量为6的切片</p><p>同样的，对于map：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">m1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>)<span class="hljs-comment">// 未指定初始容量</span><br>m2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>, <span class="hljs-number">8</span>)<span class="hljs-comment">// 指定初始容量为8</span><br></code></pre></td></tr></table></figure><p>当键值对满了之后，其能够自动扩容</p><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><ul><li>插入新键值对</li><li>获取键值对数量</li><li>查找和数据读取</li><li>删除数据</li><li>遍历map中的键值数据</li></ul><h2 id="插入新键值对"><a href="#插入新键值对" class="headerlink" title="插入新键值对"></a>插入新键值对</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>)<br>m[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;value1&quot;</span><br>m[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;value2&quot;</span><br>m[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;value3&quot;</span><br></code></pre></td></tr></table></figure><p>当插入新的键值对时，如果key已经存在，新值会覆盖旧值</p><h2 id="获取键值对数量"><a href="#获取键值对数量" class="headerlink" title="获取键值对数量"></a>获取键值对数量</h2><p>可以通过<code>len</code>来获取键值对的数量是多少，不过不能像切片那样调用cap来获取当前容量</p><h2 id="查找和数据读取"><a href="#查找和数据读取" class="headerlink" title="查找和数据读取"></a>查找和数据读取</h2><p>在对map中的键值对进行查找和读取的时候，特别要注意的就是如果key不存在，那么返回的值也是0，这样的话就会和储存的value的值为0的时候冲突，所以单纯的<code>k := m[&quot;key1&quot;]</code>是不行的，那么就需要加上条件判断：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br>v, ok := m[<span class="hljs-string">&quot;key1&quot;</span>]<br><span class="hljs-keyword">if</span> !ok &#123;<br>  <span class="hljs-comment">// &quot;key1&quot;不在map中</span><br>&#125;<br><br><span class="hljs-comment">// &quot;key1&quot;在map中，v将被赋予&quot;key1&quot;键对应的value</span><br></code></pre></td></tr></table></figure><p>可以使用空标识符来代替v，只判断键是否存在</p><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>语法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">delete</span>(m, <span class="hljs-string">&quot;key2&quot;</span>)<span class="hljs-comment">// 删除&quot;key2&quot;</span><br></code></pre></td></tr></table></figure><h2 id="遍历map中的键值数据"><a href="#遍历map中的键值数据" class="headerlink" title="遍历map中的键值数据"></a>遍历map中的键值数据</h2><p>在对map中的键值对进行遍历时，一定要注意其并不是按照顺序进行操作的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// key, value都进行迭代</span><br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br>  <span class="hljs-comment">// 打印键值对</span><br>&#125;<br><br><span class="hljs-comment">// 只对key进行迭代</span><br><span class="hljs-keyword">for</span> k, _ := <span class="hljs-keyword">range</span> m &#123;<br>  <span class="hljs-comment">// 打印key</span><br>&#125;<br><span class="hljs-keyword">for</span> k := <span class="hljs-keyword">range</span> m &#123;<br>  <span class="hljs-comment">// 打印key</span><br>&#125;<br><br><span class="hljs-comment">// 只迭代返回value</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> m &#123;<br>  <span class="hljs-comment">// 打印value</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="map变量的传递开销"><a href="#map变量的传递开销" class="headerlink" title="map变量的传递开销"></a>map变量的传递开销</h2><p>和切片类型一样，map类型也是引用类型，作为参数传递时，实际上传递的是一个描述符，在函数内部对map类型参数的修改在函数外面也是可见的</p>]]></content>
    
    
    <categories>
      
      <category>go基础回顾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go数据类型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go数据类型回顾（三）--数组、切片</title>
    <link href="/2022/12/05/go%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/go%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%89%EF%BC%89-%E6%95%B0%E7%BB%84%E3%80%81%E5%88%87%E7%89%87/"/>
    <url>/2022/12/05/go%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/go%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%89%EF%BC%89-%E6%95%B0%E7%BB%84%E3%80%81%E5%88%87%E7%89%87/</url>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>Go中的数组有两个特点：</p><ul><li>长度固定</li><li>由同种类型的元素组成</li></ul><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>数组的声明语法有两种：</p><ul><li><code>var 数组名 [数组长度]元素类型</code></li><li><code>var 数组名 [...]元素类型</code>     （初始化后Go编译器会自动判断长度）</li></ul><p>数组在Go中是占用的一块连续的内存，<code>len</code>函数可以获取到数组的长度，<code>unsafe.Sizeof</code>函数可以获取到数组占用的字节大小。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>声明了一个数组之后，如果<strong>不对它进行初始化，数组元素的值默认为0</strong>。</p><p>语法为：</p><ul><li><code>var 数组名 = [数组长度]&#123;元素1， 元素2&#125;</code></li><li><code>var 数组名 = [...]&#123;元素1， 元素2&#125;</code>     (此时会自动判断长度)</li><li><code>var 数组名 = [数组长度]&#123;索引：元素值&#125;</code>    (这种方法适用于大且稀疏的数组)</li></ul><h2 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h2><p>在Go中，可以通过下标（索引）对数组中的元素进行访问。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr = [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<span class="hljs-comment">// 6个元素</span><br>arr1 := arr[<span class="hljs-number">0</span>]<span class="hljs-comment">// 访问第一个元素</span><br>arr6 := arr[<span class="hljs-number">5</span>]<span class="hljs-comment">// 访问最后一个元素</span><br></code></pre></td></tr></table></figure><p>在Go中访问数组元素时，如果<strong>下标超出数组长度时会报错</strong>，并且，<strong>下标值不能是负数（和Python不同）</strong>。</p><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>在Go中可以声明多维数组，只要将数组长度并排就可以：</p><p><code>var arr [3][3][3]int</code></p><p>逐一展开就行。</p><p><strong>Go中的数组类型不同于C语言中的数组类型，C里面的数组变量可以视为指向数组第一个元素的指针，而Go的数组变量表示的是整个数组类型，这样就导致了Go语言数组类型的传值机制并不好</strong>。</p><h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><p>Go中切片和数组类型很像，少了长度这一限制，更为灵活。</p><h2 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h2><p><code>var 切片名 []类型</code>     (少了长度这一限制)</p><p>但是切片也可以通过<code>len</code>函数获取到当前状态下的长度</p><h2 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h2><p>和数组类型一样，只不过去掉了长度固定的限制。</p><p>此时也可以向切片中添加元素，使用<code>append</code>函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> sli = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<br>sli = <span class="hljs-built_in">append</span>(sli, <span class="hljs-number">7</span>)<span class="hljs-comment">// 切片变为[1 2 3 4 5 6 7]</span><br></code></pre></td></tr></table></figure><h2 id="底层逻辑"><a href="#底层逻辑" class="headerlink" title="底层逻辑"></a>底层逻辑</h2><p>在Go中，<strong>切片本质上还是数组</strong>，切片是由三部分构成的：</p><ul><li>Array，指向底层的数组</li><li>len， 切片类型的长度</li><li>cap， 数组类型的容量</li></ul><p>在切片类型中，len永远是小于等于cap的。</p><p>Go编译器会为每个新创建的切片建立一个底层的数组，默认cap和len一样长，但是其实是可以指定的：</p><ul><li>通过<code>make</code>函数来创建切片，并指定底层数组的长度</li><li>通过<code>array[low: high: max]</code>基于一个已经存在的数组创建切片，即<strong>数组的切片化</strong></li><li>基于切片创建切片</li></ul><h3 id="make函数"><a href="#make函数" class="headerlink" title="make函数"></a><code>make</code>函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// make语法</span><br>sli := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>)<span class="hljs-number">3</span>为切片的初始长度，<span class="hljs-number">6</span>为底层数组的容量<br><span class="hljs-comment">//不指明容量</span><br>sli := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">6</span>) 切片的初始长度和容量都为<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h3 id="array-low-high-max-函数"><a href="#array-low-high-max-函数" class="headerlink" title="array[low: high: max]函数"></a><code>array[low: high: max]</code>函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr = [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125; <span class="hljs-comment">// 创建一个数组</span><br><span class="hljs-comment">// 基于此数组创建一个切片</span><br>sli := arr[<span class="hljs-number">3</span>: <span class="hljs-number">7</span>: <span class="hljs-number">9</span>]<br><span class="hljs-comment">// 起始元素为low对应于数组中的下标</span><br><span class="hljs-comment">// len为high-low即为4</span><br><span class="hljs-comment">// cap为max-low即为6</span><br><br>sl[<span class="hljs-number">0</span>] += <span class="hljs-number">10</span><br><span class="hljs-comment">// 由于切片的底层是数组，所以对切片的修改也会改变底层数组的值</span><br></code></pre></td></tr></table></figure><p>省略<code>max</code>时<code>max</code>就是数组的最大长度</p><h2 id="动态扩容"><a href="#动态扩容" class="headerlink" title="动态扩容"></a>动态扩容</h2><p>当len长度等于cap容量时，此时再append追加元素时，就会导致cap容量不够，Go语言为了解决这个问题，就设计了动态扩容机制，此时<strong>会copy这个数组给一个新的数组，这个新数组的cap会变成原来数组的两倍，以后就会在这个新数组上进行操作，</strong>以此类推。</p><p>如果触发了自动扩容机制，那么之后的操作就不会是在原来的数组上操作了。</p>]]></content>
    
    
    <categories>
      
      <category>go基础回顾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go数据类型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go数据类型回顾(二)--byte、rune、字符串</title>
    <link href="/2022/12/04/go%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/go%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-byte%E3%80%81rune%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2022/12/04/go%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/go%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-byte%E3%80%81rune%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="rune"><a href="#rune" class="headerlink" title="rune"></a><code>rune</code></h1><p>在go中<code>rune</code>的源码定义为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> <span class="hljs-type">rune</span> = <span class="hljs-type">int32</span><br></code></pre></td></tr></table></figure><p><code>rune</code>在本质上就是<code>int32</code>类型，占有四个字节，用来<strong>表示一个Unicode字符（码点）</strong></p><h1 id="byte"><a href="#byte" class="headerlink" title="byte"></a><code>byte</code></h1><p>同样的，直接上源码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> <span class="hljs-type">byte</span> = <span class="hljs-type">uint8</span><br></code></pre></td></tr></table></figure><p>其在本质上就是<code>uint8</code>类型，表示1个字节，<strong>用来表示ASCII表中的一个字符</strong></p><h1 id="string"><a href="#string" class="headerlink" title="string"></a><code>string</code></h1><h2 id="原生优点"><a href="#原生优点" class="headerlink" title="原生优点"></a>原生优点</h2><p>go内置的字符串类型是原生的，优点如下：</p><ul><li>数据不可变，提高了并发安全性和存储利用率</li><li>获取长度的时间复杂度是常数</li><li>所见即所得</li><li>对非ASCII码提供了原生支持，消除了源码在不同环境下显示乱码的可能（<strong>go采用Unicode字符集，以UTF-8编码格式存储在内存中</strong>）</li></ul><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p><strong>字符串未赋值时默认为空字符。</strong></p><p>在go中，对于字符串的组成，有两种看法，一种就是从<strong>字节</strong>的角度，另一种就是从<strong>字符</strong>的角度。</p><p>从字节角度上：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;中国人&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;The length of s = %d\n&quot;</span>, <span class="hljs-built_in">len</span>(s))<span class="hljs-comment">// 对应9个字符</span><br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;0x%x &quot;</span>, s[i])<span class="hljs-comment">// 0xe4 0xb8 0xad 0xe5 0x9b 0xbd 0xe4 0xba 0xba</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;\n&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>从字符角度上：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;unicode/utf8&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;中国人&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;The length of s = %d\n&quot;</span>, utf8.RuneCountInString(s))<span class="hljs-comment">// 对应3个字符（也就是3个Unicode字符）</span><br><br><span class="hljs-keyword">for</span> _, i := <span class="hljs-keyword">range</span> s &#123;<br>fmt.Printf(<span class="hljs-string">&quot;0x%x &quot;</span>, i)<span class="hljs-comment">// 0x4e2d 0x56fd 0x4eba</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;\n&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>一个Unicode码点就会对应一个Unicode字符，通常来说，<strong>rune类型会用来表示一个Unicode字符</strong>，一个<code>rune</code>类型（<code>int32</code>类型）就是一个字符，字符串可以看成是<code>rune</code>类型的集合。</p><h3 id="字符的表示方法"><a href="#字符的表示方法" class="headerlink" title="字符的表示方法"></a>字符的表示方法</h3><ul><li>最直观的字符字面值</li><li>Unicode专用的转义字符（<code>\u</code>和<code>\U</code>）</li><li>直接用整型值</li></ul><p>对于字符的初始化，最直观的就是<strong>由单引号括起的字符字面值</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-string">&#x27;a&#x27;</span><span class="hljs-comment">// ASCII字符</span><br><span class="hljs-string">&#x27;中&#x27;</span><span class="hljs-comment">// Unicode字符集中的中文字符</span><br><span class="hljs-string">&#x27;\n&#x27;</span><span class="hljs-comment">// 换行字符</span><br><span class="hljs-string">&#x27;\&#x27;&#x27;</span><span class="hljs-comment">// 单引号字符</span><br><br><span class="hljs-comment">// 它们本质上都是int32类型的</span><br></code></pre></td></tr></table></figure><p>还可以使用<strong>Unicode专用的转义字符来表示</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-string">&#x27;\u4e2d&#x27;</span><span class="hljs-comment">// 字符：中</span><br><span class="hljs-string">&#x27;\U00004e2d&#x27;</span><span class="hljs-comment">// 字符：中</span><br><span class="hljs-string">&#x27;\u0027&#x27;</span><span class="hljs-comment">// 单引号字符</span><br></code></pre></td></tr></table></figure><p><code>\u</code>能够接四个十六进制的数，<code>\U</code>能够接八个十六进制的数，<code>\u</code>不足以表示的时候，可以使用<code>\U</code>。</p><p>还可以<strong>直接用整型值表示</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-string">&#x27;\x27&#x27;</span><span class="hljs-comment">// 使用十六进制表示的单引号字符</span><br><span class="hljs-string">&#x27;\047&#x27;</span><span class="hljs-comment">// 使用八进制表示的单引号字符</span><br></code></pre></td></tr></table></figure><h3 id="字符串的表示方法"><a href="#字符串的表示方法" class="headerlink" title="字符串的表示方法"></a>字符串的表示方法</h3><p>对于字符串的表示，就是对上面<strong>字符表示的组合，然后用双引号引起来</strong>：</p><ul><li>最直观的字面值组合</li><li>Unicode转义组合</li><li>整型组合</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;abc\n&quot;</span><br><span class="hljs-string">&quot;中国人&quot;</span><br><span class="hljs-string">&quot;\u4e2d\u56fd\u4eba&quot;</span> <span class="hljs-regexp">//</span> 中国人<br><span class="hljs-string">&quot;\U00004e2d\U000056fd\U00004eba&quot;</span> <span class="hljs-regexp">//</span> 中国人<br><span class="hljs-string">&quot;中\u56fd\u4eba&quot;</span> <span class="hljs-regexp">//</span> 中国人，不同字符字面值形式混合在一起<br><span class="hljs-string">&quot;\xe4\xb8\xad\xe5\x9b\xbd\xe4\xba\xba&quot;</span> <span class="hljs-regexp">//</span> 十六进制表示的字符串字面值：中国人<br></code></pre></td></tr></table></figure><p>但是，对于最后一个十六进制表示的字符串字面值，并不是像上面那样是3个，而是用9个十六进制的整型数值表示。</p><p>原因就是这是<strong>Unicode字符串的UTF-8编码值</strong>。</p><p>在UTF-32的编码方案中，就是一个Unicode码点和一个UTF-32编码值一一对应，这样虽然好理解，但是存在缺点：</p><ul><li>每个Unicode字符进行UTF-32编码后得到的值都会占用4个字节，使得空间利用率低</li><li>由于采用4字节的固定长度进行编码，导致与采用1字节编码处理的ASCII字符集不兼容</li><li>在使用4个字节存储和传输一个整型数时，需要考虑不同平台的字节序问题</li></ul><p>为了解决这些问题，go语言之父就发明了UTF-8编码方案，其能够根据Unicode码点值的大小动态的使用编码要用的字符数量。</p><p>字符数量从1-4个字符不等：</p><ul><li><strong>前128个与ASCII字符集重复的码点（U+0000～U+007F）使用1个字节表示</strong></li><li>带变音符号的拉丁文、希腊文、西里尔字母、阿拉伯文等使用 2 个字节表示</li><li><strong>东亚文字（包括汉字）使用 3 个字节表示</strong></li><li>其他极少使用的语言的字符则使用 4 个字节表示</li></ul><p>现在，UTF-8编码方案已经成为了Unicode编码方案的标准，各个平台也都在使用UTF-8编码方案对Unicode字符集进行编码处理。</p><p>go中有对Unicode字符集（<code>rune</code>类型）进行编解码的UTF-8包：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;unicode/utf8&quot;</span><br>)<br><br><span class="hljs-comment">// rune -&gt; []byte</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">encodeRune</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> r <span class="hljs-type">rune</span> = <span class="hljs-number">0x4E2D</span><br>fmt.Printf(<span class="hljs-string">&quot;The unicode charactor is %c\n&quot;</span>, r) <span class="hljs-comment">// 中</span><br>buf := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">3</span>)<br>_ = utf8.EncodeRune(buf, r)                       <span class="hljs-comment">// 对r进行编码</span><br>fmt.Printf(<span class="hljs-string">&quot;utf-8 representation is 0x%X\n&quot;</span>, buf) <span class="hljs-comment">// 0xE4B8AD</span><br>&#125;<br><br><span class="hljs-comment">// []byte -&gt; rune</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">decodeRune</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> buf = []<span class="hljs-type">byte</span>&#123;<span class="hljs-number">0xE4</span>, <span class="hljs-number">0xB8</span>, <span class="hljs-number">0xAD</span>&#125;<br>r, _ := utf8.DecodeRune(buf)   <span class="hljs-comment">// 对buf进行utf-8解码 </span><br>fmt.Printf(<span class="hljs-string">&quot;the unicode charactor after decoding [0xE4, 0xB8, 0xAD] is %s\n&quot;</span>, <span class="hljs-type">string</span>(r)) <span class="hljs-comment">// 中</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="go中string类型的底层逻辑"><a href="#go中string类型的底层逻辑" class="headerlink" title="go中string类型的底层逻辑"></a>go中<code>string</code>类型的底层逻辑</h2><p>在go中，<code>string</code>类型是一个描述符，<strong>它本身并不真正的储存字符串数据，仅仅是由一个指向底层存储的指针和存储一个字符串的长度</strong>。</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8s5cxi3p1j31d60mrq3m.jpg" alt="wps_doc_1"></p><h2 id="string类型常见操作"><a href="#string类型常见操作" class="headerlink" title="string类型常见操作"></a><code>string</code>类型常见操作</h2><p>在go中，<code>string</code>有如下几种操作：</p><ul><li>下表操作</li><li>字符迭代</li><li>字符串拼接</li><li>字符串比较</li><li>字符串转换</li></ul><h3 id="下标操作"><a href="#下标操作" class="headerlink" title="下标操作"></a>下标操作</h3><p>此操作是对底层数组的操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;中国人&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;0x%x\n&quot;</span>, s[<span class="hljs-number">0</span>])<span class="hljs-comment">// 0xe4 字符：中</span><br></code></pre></td></tr></table></figure><h3 id="字符迭代"><a href="#字符迭代" class="headerlink" title="字符迭代"></a>字符迭代</h3><p>在go中有两种迭代方式：</p><ul><li>常规for迭代</li><li>for range 迭代</li></ul><p>通过for迭代，得到的是字符串经过编码后的每个字节：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;中国人&quot;</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;index: %d, value: 0x%x\n&quot;</span>, i, s[i])<br>&#125; <br><br><span class="hljs-comment">// index: 0, value: 0xe4</span><br><span class="hljs-comment">// index: 1, value: 0xb8</span><br><span class="hljs-comment">// index: 2, value: 0xad</span><br><span class="hljs-comment">// index: 3, value: 0xe5</span><br><span class="hljs-comment">// index: 4, value: 0x9b</span><br><span class="hljs-comment">// index: 5, value: 0xbd</span><br><span class="hljs-comment">// index: 6, value: 0xe4</span><br><span class="hljs-comment">// index: 7, value: 0xba</span><br><span class="hljs-comment">// index: 8, value: 0xba</span><br></code></pre></td></tr></table></figure><p><code>len</code>获取的是字节个数</p><p>通过for range迭代，得到的是字符串对应的Unicode码点及字符在字符串中的偏移值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;中国人&quot;</span><br><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> s &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;index: %d, value: 0x%x\n&quot;</span>, i, v)<br>&#125;<br><br><span class="hljs-comment">// index: 0, value: 0x4e2d</span><br><span class="hljs-comment">// index: 3, value: 0x56fd</span><br><span class="hljs-comment">// index: 6, value: 0x4eba</span><br></code></pre></td></tr></table></figure><h3 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h3><p>go是支持+&#x2F;+&#x3D;这样的运算符来对字符串进行连接的，但是这种方法并不是效率最高的</p><h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><p>Go 字符串类型支持各种比较关系操作符，包括 &#x3D; &#x3D;、!&#x3D; 、&gt;&#x3D;、&lt;&#x3D;、&gt; 和 &lt;。在比较的时候，会从第一个开始依次进行比较</p><p>比较大概顺序为：</p><p>先比较len——再比较指针——再比较内容</p><h2 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换</h2><p>go中支持的转换有：</p><ul><li>string &lt;–&gt; []rune</li><li>string &lt;–&gt; []byte</li></ul><p>这种转换不用调用函数，只用采用格式化和显示转换就可以</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span> = <span class="hljs-string">&quot;中国人&quot;</span><br>                      <br><span class="hljs-comment">// string -&gt; []rune</span><br>rs := []<span class="hljs-type">rune</span>(s) <br>fmt.Printf(<span class="hljs-string">&quot;%x\n&quot;</span>, rs) <span class="hljs-comment">// [4e2d 56fd 4eba]</span><br>                <br><span class="hljs-comment">// string -&gt; []byte</span><br>bs := []<span class="hljs-type">byte</span>(s) <br>fmt.Printf(<span class="hljs-string">&quot;%x\n&quot;</span>, bs) <span class="hljs-comment">// e4b8ade59bbde4baba</span><br>                <br><span class="hljs-comment">// []rune -&gt; string</span><br>s1 := <span class="hljs-type">string</span>(rs)<br>fmt.Println(s1) <span class="hljs-comment">// 中国人</span><br>                <br><span class="hljs-comment">// []byte -&gt; string</span><br>s2 := <span class="hljs-type">string</span>(bs)<br>fmt.Println(s2) <span class="hljs-comment">// 中国人</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>go基础回顾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go数据类型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go数据类型回顾(一)--整形、浮点型、复数型</title>
    <link href="/2022/12/02/go%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/go%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B--%E6%95%B4%E5%9E%8B%E3%80%81%E6%B5%AE%E7%82%B9%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2022/12/02/go%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/go%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B--%E6%95%B4%E5%9E%8B%E3%80%81%E6%B5%AE%E7%82%B9%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="整型（int和uint）"><a href="#整型（int和uint）" class="headerlink" title="整型（int和uint）"></a>整型（<code>int</code>和<code>uint</code>）</h1><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><table><thead><tr><th>数据类型</th><th>类型宽度（bit）</th><th>类型宽度（byte）</th><th>备注</th></tr></thead><tbody><tr><td><code>int</code></td><td>32位或者64位</td><td>4或8个字节</td><td>与所用计算机的操作系统的位数有关</td></tr><tr><td><code>int8</code></td><td>8位</td><td>1个字节</td><td></td></tr><tr><td><code>int16</code></td><td>16位</td><td>2个字节</td><td></td></tr><tr><td><code>int32</code></td><td>32位</td><td>4个字节</td><td>相当于32位的操作系统下的<code>int</code>类型</td></tr><tr><td><code>int64</code></td><td>64位</td><td>8个字节</td><td>相当于64位的操作系统下的<code>int</code>类型</td></tr><tr><td><code>uint</code></td><td>32位或者64位</td><td>4或8个字节</td><td>与所用计算机的操作系统的位数有关</td></tr><tr><td><code>uint8</code></td><td>8位</td><td>1个字节</td><td></td></tr><tr><td><code>uint16</code></td><td>16位</td><td>2个字节</td><td></td></tr><tr><td><code>uint32</code></td><td>32位</td><td>4个字节</td><td>相当于32位的操作系统下的<code>uint</code>类型</td></tr><tr><td><code>uint64</code></td><td>64位</td><td>8个字节</td><td>相当于64位的操作系统下的<code>uint</code>类型</td></tr></tbody></table><p>其中，<code>int</code>和<code>uint</code>的类型区别在于<code>int</code>是有符号的整型，而<code>uint</code>是无符号的整型。</p><p>bit和byte的关系是：一个byte字节由八个bit位组成。</p><p>对于<code>int</code>和<code>uint</code>后面的数字，代表的是该类型的整型所能表示的<strong>整数范围</strong>。例如：</p><p>对于<code>int8</code>和<code>uint8</code>，<code>uint8</code>对应的bit位为8位，则表示数值的范围为[0, 2^8^-1]即为[0, 255]；而<code>int8</code>代表的是有符号的数据类型，那么就对半分呗；从负数开始到正数，也就是[-128, 127]。</p><p>同样，对于<code>uint16</code>类型表示的整数范围为[0, 65535]</p><h2 id="声明并赋值"><a href="#声明并赋值" class="headerlink" title="声明并赋值"></a>声明并赋值</h2><p>在go中，声明变量的方式为<code>var 变量名 数据类型</code></p><p>go还支持同时声明变量并赋值（此时可以省去数据类型，因为go会根据赋值内容自动进行判断）</p><p>go还可以<strong>同时声明多个变量</strong>和<strong>同时声明多个变量并赋值</strong>的声明操作</p><p><strong>整型未赋值时默认为0。</strong></p><p>即go的声明操作：</p><ul><li>声明单个变量</li><li>声明单个变量并赋值</li><li>同时声明多个变量</li><li>同时声明多个变量并赋值</li><li>短变量声明（此时作用域为局部）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 声明单个整数类型的变量</span><br><span class="hljs-keyword">var</span> a <span class="hljs-type">int32</span><br>a = <span class="hljs-number">1024</span><br><span class="hljs-comment">// 声明单个变量并赋值</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">int32</span> = <span class="hljs-number">1024</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-number">1024</span><span class="hljs-comment">// 若不指定，此时会自动判断其数据类型为int类型</span><br><span class="hljs-comment">// 同时声明多个变量</span><br><span class="hljs-keyword">var</span> (<br>c <span class="hljs-type">int</span><br>  d <span class="hljs-type">int8</span><br>  e <span class="hljs-type">int32</span><br>)<br><span class="hljs-comment">// 同时声明多个变量并赋值</span><br><span class="hljs-keyword">var</span> (<br>c <span class="hljs-type">int</span> = <span class="hljs-number">1</span><br>  d <span class="hljs-type">int8</span> = <span class="hljs-number">11</span><br>  e <span class="hljs-type">int32</span> = <span class="hljs-number">111</span><br>  f = <span class="hljs-number">1111</span><span class="hljs-comment">// 不指定，会自动判断其类型为int类型</span><br>)<br><span class="hljs-comment">// 短变量声明</span><br>a := <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>一般我们进行赋值时，会采用我们熟悉的十进制进行赋值，但是，我们也可以指定其他的赋值方式，只要在你赋值的内容前面加上<code>0b或0B</code>(二进制)、<code>0o或0O</code>（八进制）、<code>0x或0X</code>（十六进制）就可以啦。</p><h1 id="浮点型（float32和float64）"><a href="#浮点型（float32和float64）" class="headerlink" title="浮点型（float32和float64）"></a>浮点型（<code>float32</code>和<code>float64</code>）</h1><h2 id="类型-1"><a href="#类型-1" class="headerlink" title="类型"></a>类型</h2><p>在go中，浮点型的数据类型只有两种分类：</p><ul><li>单精度（<code>float32</code>） 小数部分能精确到7位</li><li>双精度（<code>float64</code>）小数部分能精确到16位</li></ul><p><strong>浮点型表示的数值并不精确，它是有精度限制的。</strong></p><p>go中的浮点型数据类型采用IEEE754浮点数标准对数据进行存储和表示。</p><h2 id="声明赋值"><a href="#声明赋值" class="headerlink" title="声明赋值"></a>声明赋值</h2><p>在声明浮点型数据类型的时候，同整形数据类型相同。</p><p><strong>浮点型未赋值时默认为0.000000。</strong></p><p>同样的，对于浮点型数据类型，可以采用我们直观的<strong>小数形式</strong>进行赋值，也可以采用<strong>科学记数法</strong>的方式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 声明浮点型变量</span><br><span class="hljs-keyword">var</span> f1 <span class="hljs-type">float32</span><br><span class="hljs-keyword">var</span> f2 <span class="hljs-type">float64</span><br><span class="hljs-comment">// 声明浮点型变量并同时进行赋值</span><br><span class="hljs-comment">// 方式一：直观小数</span><br><span class="hljs-keyword">var</span> f1 <span class="hljs-type">float32</span> = <span class="hljs-number">1.3</span><br><span class="hljs-keyword">var</span> f2 = <span class="hljs-number">1.3</span><span class="hljs-comment">// 不指明是float32还是float64的话默认与操作系统的位数有关</span><br><span class="hljs-comment">// 方式二：科学记数法</span><br><span class="hljs-keyword">var</span> f1 <span class="hljs-type">float64</span> = <span class="hljs-number">1.234e+1</span><span class="hljs-comment">// 即12.34</span><br></code></pre></td></tr></table></figure><h2 id="格式化打印"><a href="#格式化打印" class="headerlink" title="格式化打印"></a>格式化打印</h2><p>对于浮点型数据类型，在打印的时候可以控制输出小数点的位数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> f <span class="hljs-type">float32</span> = <span class="hljs-number">1.3</span><br>fmt.Printf(<span class="hljs-string">&quot;%f\n&quot;</span>, f)<span class="hljs-comment">// 默认为输出6位小数（无论是单精度还是双精度）</span><br>fmt.Printf(<span class="hljs-string">&quot;%.6f\n&quot;</span>, f)<span class="hljs-comment">// 输出6位小数</span><br>fmt.Printf(<span class="hljs-string">&quot;%.7f\n&quot;</span>, f)<span class="hljs-comment">// 输出7位小数</span><br>fmt.Printf(<span class="hljs-string">&quot;%.8f\n&quot;</span>, f)<span class="hljs-comment">// 输出8位小数（超出了精度）</span><br>&#125;<br><br><span class="hljs-comment">// 输出结果：</span><br><span class="hljs-comment">// 1.300000</span><br><span class="hljs-comment">// 1.300000</span><br><span class="hljs-comment">// 1.3000000</span><br><span class="hljs-comment">// 1.29999995</span><br></code></pre></td></tr></table></figure><h1 id="复数型（complex64和complex128）"><a href="#复数型（complex64和complex128）" class="headerlink" title="复数型（complex64和complex128）"></a>复数型（<code>complex64</code>和<code>complex128</code>）</h1><p>和整数型与浮点型相比，复数类型的应用领域更加的小众，只需简单了解就行。</p><table><thead><tr><th>类型</th><th>构成</th><th>备注</th></tr></thead><tbody><tr><td><code>complex64</code></td><td>实部和虚部都由<code>float32</code>构成</td><td></td></tr><tr><td><code>complex128</code></td><td>实部和虚部都有<code>float64</code>构成</td><td>声明不指明类型时的默认类型</td></tr></tbody></table><p>复数的表示有三种方式：</p><ul><li>直观表示</li><li>调用<code>complex</code>函数</li><li>分别用<code>real</code>和<code>imag</code>函数表示实部和虚部</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 直观表示</span><br><span class="hljs-keyword">var</span> c <span class="hljs-type">complex128</span> = <span class="hljs-number">1</span> + <span class="hljs-number">2i</span><br><span class="hljs-keyword">var</span> d = <span class="hljs-number">0</span>o123 + <span class="hljs-number">.12345E+5i</span><span class="hljs-comment">// 83 + 12345i</span><br><br><span class="hljs-comment">// 调用complex函数</span><br><span class="hljs-keyword">var</span> c = <span class="hljs-built_in">complex</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<span class="hljs-comment">// 1 + 2i</span><br><span class="hljs-keyword">var</span> d = <span class="hljs-built_in">complex</span>(<span class="hljs-number">0</span>o123, <span class="hljs-number">.12345E+5</span>)<span class="hljs-comment">// 83 + 12345i</span><br><br><span class="hljs-comment">// real和imag显示实部和虚部</span><br><span class="hljs-keyword">var</span> c = <span class="hljs-built_in">complex</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<span class="hljs-comment">// 1 + 2i</span><br>r := <span class="hljs-built_in">real</span>(c)<span class="hljs-comment">// 1.000000</span><br>i := <span class="hljs-built_in">real</span>(c)<span class="hljs-comment">// 2.000000</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>go基础回顾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go数据类型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git基础操作</title>
    <link href="/2022/11/22/Git%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/11/22/Git%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<blockquote><p>持续更新中…</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8e7hswgf1j322r0u045s.jpg" alt="Git"></p><p>对于<code>Git</code>的相关操作，后面其他的会用到的再补充。</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vscode下的latex配置</title>
    <link href="/2022/11/18/vscode%E4%B8%8B%E7%9A%84latex%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/11/18/vscode%E4%B8%8B%E7%9A%84latex%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="下载texlive和vscode"><a href="#下载texlive和vscode" class="headerlink" title="下载texlive和vscode"></a>下载texlive和vscode</h2><ul><li>首先下载好texlive<ul><li>windows版本就是texlive</li><li>macos版本则为mactex</li></ul></li><li>下载vscode编辑器<ul><li>可以下载上中文插件</li><li>扩展下载latex workshop</li></ul></li></ul><p>安装texlive和vscode可以在csdn上面搜索相关教程，对于texlive不能科学上网的话需要镜像下载</p><h2 id="在vscode里面配置latex相关内容"><a href="#在vscode里面配置latex相关内容" class="headerlink" title="在vscode里面配置latex相关内容"></a>在vscode里面配置latex相关内容</h2><ul><li>在vscode的setting json里面配置latex 位置是左上角code里面的设置，在用户拓展json里面点击<code>在setting.json中编辑</code><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h89n9kavdcj30ta0m2wgo.jpg" alt="截屏2022-11-18 21.48.02" style="zoom:50%;" /></li></ul><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8a7p7zyd1j318g0u00vy.jpg" alt="截屏2022-11-19 10.08.23"></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;latex-workshop.latex.tools&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pdflatex&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pdflatex&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-string">&quot;-synctex=1&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;-interaction=nonstopmode&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;-file-line-error&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;%DOCFILE%&quot;</span><br>        <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xelatex&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xelatex&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-string">&quot;-synctex=1&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;-interaction=nonstopmode&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;-file-line-error&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;%DOCFILE%&quot;</span><br>        <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;bibtex&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;bibtex&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-string">&quot;%DOCFILE%&quot;</span><br>        <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;latex-workshop.latex.recipes&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xelatex&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;tools&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-string">&quot;xelatex&quot;</span><br>        <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pdflatex&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;tools&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-string">&quot;pdflatex&quot;</span><br>        <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xe-&gt;bib-&gt;xe-&gt;xe&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;tools&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-string">&quot;xelatex&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;bibtex&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;xelatex&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;xelatex&quot;</span><br>        <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pdf-&gt;bib-&gt;pdf-&gt;pdf&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;tools&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-string">&quot;pdflatex&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;bibtex&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;pdflatex&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;pdflatex&quot;</span><br>        <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;latex-workshop.latex.clean.fileTypes&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;*.aux&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;*.bbl&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;*.blg&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;*.idx&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;*.ind&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;*.lof&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;*.lot&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;*.out&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;*.toc&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;*.acn&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;*.acr&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;*.alg&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;*.glg&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;*.glo&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;*.gls&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;*.ist&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;*.fls&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;*.log&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;*.fdb_latexmk&quot;</span><br><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-comment">//tex文件浏览器，可选项为&quot;none&quot; &quot;browser&quot; &quot;tab&quot; &quot;external&quot;</span><br><span class="hljs-attr">&quot;latex-workshop.view.pdf.viewer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;tab&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-comment">//自动编译tex文件</span><br><span class="hljs-attr">&quot;latex-workshop.latex.autoBuild.run&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;onFileChange&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-comment">//显示内容菜单：（1）编译文件；（2）定位游标</span><br><span class="hljs-attr">&quot;latex-workshop.showContextMenu&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-comment">//显示错误</span><br><span class="hljs-attr">&quot;latex-workshop.message.error.show&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-comment">//显示警告</span><br><span class="hljs-attr">&quot;latex-workshop.message.warning.show&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-comment">//从使用的包中自动补全命令和环境</span><br><span class="hljs-attr">&quot;latex-workshop.intellisense.package.enabled&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-comment">//设置为never，为不清除辅助文件</span><br><span class="hljs-attr">&quot;latex-workshop.latex.autoClean.run&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;never&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-comment">//设置vscode编译tex文档时的默认编译链</span><br><span class="hljs-attr">&quot;latex-workshop.latex.recipe.default&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;lastUsed&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-comment">// 用于反向同步的内部查看器的键绑定。ctrl/cmd +点击(默认)或双击</span><br><span class="hljs-attr">&quot;latex-workshop.view.pdf.internal.synctex.keybinding&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;double-click&quot;</span><span class="hljs-punctuation">,</span><br><br></code></pre></td></tr></table></figure><p>配置上述代码</p><p><strong>必须在写在<code>&#123;&#125;</code>里面，如果<code>&#123;&#125;</code>里面有内容，你就需要在最后一个代码后面加上<code>,</code>，然后在下面配置上述代码，注意缩进</strong></p><h2 id="在vscode编写latex格式的文件并进行预览"><a href="#在vscode编写latex格式的文件并进行预览" class="headerlink" title="在vscode编写latex格式的文件并进行预览"></a>在vscode编写latex格式的文件并进行预览</h2><ul><li>然后保存这个修改后的文件，重新打开vscode</li><li>在工作区新建一个文件夹，在文件夹里面新建一个后缀为<code>tex</code>的文件</li><li>在里面加入这个模版</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-comment">% -*- coding: utf-8 -*-</span><br><span class="hljs-keyword">\documentclass</span>&#123;article&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;listings&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;ctex&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;graphicx&#125;<br><span class="hljs-keyword">\usepackage</span>[a4paper, body=&#123;18cm,22cm&#125;]&#123;geometry&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;amsmath,amssymb,amstext,wasysym,enumerate,graphicx&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;float,abstract,booktabs,indentfirst,amsmath&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;array&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;booktabs&#125; <span class="hljs-comment">%调整表格线与上下内容的间隔</span><br><span class="hljs-keyword">\usepackage</span>&#123;multirow&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;diagbox&#125;<br><span class="hljs-keyword">\renewcommand</span><span class="hljs-keyword">\arraystretch</span>&#123;1.4&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;indentfirst&#125;<br><span class="hljs-keyword">\setlength</span>&#123;<span class="hljs-keyword">\parindent</span>&#125;&#123;2em&#125;<br> <br><span class="hljs-keyword">\geometry</span>&#123;left=2.8cm,right=2.2cm,top=2.5cm,bottom=2.5cm&#125;<br><span class="hljs-comment">%\geometry&#123;left=3.18cm,right=3.18cm,top=2.54cm,bottom=2.54cm&#125;</span><br> <br><span class="hljs-keyword">\graphicspath</span>&#123;&#123;figures/&#125;&#125;<br> <br><span class="hljs-keyword">\title</span>&#123;<span class="hljs-keyword">\heiti</span> 题目 &#125;<br> <br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br> <br>    <span class="hljs-keyword">\maketitle</span><br>    <br>    <span class="hljs-keyword">\vspace</span>&#123;5cm&#125;<br>    <br>    <span class="hljs-keyword">\begin</span>&#123;table&#125;[h]<br>        <span class="hljs-keyword">\centering</span><br>        <span class="hljs-keyword">\begin</span>&#123;Large&#125;<br>            <span class="hljs-keyword">\begin</span>&#123;tabular&#125;&#123;p&#123;3cm&#125; p&#123;7cm&#125;&lt;&#123;<span class="hljs-keyword">\centering</span>&#125;&#125;<br>                学  <span class="hljs-keyword">\qquad</span>  校: <span class="hljs-built_in">&amp;</span>  *********     <span class="hljs-keyword">\\</span> <span class="hljs-keyword">\cline</span>&#123;2-2&#125;<br>                学 <span class="hljs-keyword">\qquad</span> 院:      <span class="hljs-built_in">&amp;</span> ****学院   <span class="hljs-keyword">\\</span> <span class="hljs-keyword">\cline</span>&#123;2-2&#125;<br>                成  <span class="hljs-keyword">\qquad</span>  员: <span class="hljs-built_in">&amp;</span> *** <span class="hljs-keyword">\quad</span> ** <span class="hljs-keyword">\quad</span> *** <span class="hljs-keyword">\\</span> <span class="hljs-keyword">\cline</span>&#123;2-2&#125;<br>                <span class="hljs-built_in">&amp;</span> **<span class="hljs-keyword">\quad</span> ** <span class="hljs-keyword">\quad</span> *** <span class="hljs-keyword">\\</span> <span class="hljs-keyword">\cline</span>&#123;2-2&#125;<br>                指导教师:       <span class="hljs-built_in">&amp;</span> **** <span class="hljs-keyword">\\</span> <span class="hljs-keyword">\cline</span>&#123;2-2&#125;<br>            <span class="hljs-keyword">\end</span>&#123;tabular&#125;<br>        <span class="hljs-keyword">\end</span>&#123;Large&#125;     <br>    <span class="hljs-keyword">\end</span>&#123;table&#125;<br>    <br>    <span class="hljs-keyword">\newpage</span><br> <br>    <span class="hljs-keyword">\tableofcontents</span><br>    <br>    <span class="hljs-keyword">\newpage</span><br>    <br>    <span class="hljs-keyword">\section</span>&#123;系统概述&#125;<br>    <br>    <br> <br><span class="hljs-keyword">\end</span>&#123;document&#125;<br> <br><span class="hljs-comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%Library%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span><br> <br><span class="hljs-comment">% 1. 脚注用法</span><br>    LaTeX<span class="hljs-keyword">\footnote</span>&#123;Latex is Latex&#125; is a good software<br> <br><span class="hljs-comment">%2. 强调</span><br>    <span class="hljs-keyword">\emph</span>&#123;center of percussion&#125; <span class="hljs-comment">%[Brody 1986], %\lipsum[5]</span><br> <br><span class="hljs-comment">%3. 随便生成一段话</span><br>    <span class="hljs-keyword">\lipsum</span>[4]<br> <br><span class="hljs-comment">%4. 列条目</span><br>    <span class="hljs-keyword">\begin</span>&#123;itemize&#125;<br>    <span class="hljs-keyword">\item</span> the angular velocity of the bat,<br>    <span class="hljs-keyword">\item</span> the velocity of the ball, and<br>    <span class="hljs-keyword">\item</span> the position of impact along the bat.<br>    <span class="hljs-keyword">\end</span>&#123;itemize&#125;<br> <br><span class="hljs-comment">%5. 表格用法</span><br>    <span class="hljs-keyword">\begin</span>&#123;table&#125;[h]<br>    <span class="hljs-keyword">\centering</span>  <br>    <span class="hljs-keyword">\begin</span>&#123;tabular&#125;&#123;c|cc&#125;<br>        <span class="hljs-keyword">\hline</span><br>        年份 <span class="hljs-built_in">&amp;</span> <span class="hljs-keyword">\multicolumn</span>&#123;2&#125;&#123;c&#125;&#123;指标&#125;<span class="hljs-keyword">\\</span><br>        <span class="hljs-keyword">\hline</span><br>        2017 <span class="hljs-built_in">&amp;</span> 0.9997 <span class="hljs-built_in">&amp;</span> 0.0555 <span class="hljs-keyword">\\</span><br>        2018 <span class="hljs-built_in">&amp;</span> 0.9994 <span class="hljs-built_in">&amp;</span> 0      <span class="hljs-keyword">\\</span><br>        2019 <span class="hljs-built_in">&amp;</span> 0.9993 <span class="hljs-built_in">&amp;</span> 0      <span class="hljs-keyword">\\</span><br>        <span class="hljs-keyword">\hline</span><br>    <span class="hljs-keyword">\end</span>&#123;tabular&#125;<br>    <span class="hljs-keyword">\caption</span>&#123;NAME&#125;<span class="hljs-keyword">\label</span>&#123;SIGN&#125;<br>    <span class="hljs-keyword">\end</span>&#123;table&#125;<br>    <span class="hljs-keyword">\begin</span>&#123;center&#125;<br>        <span class="hljs-keyword">\begin</span>&#123;tabular&#125;&#123;c|cclcrcc&#125;<br>            <span class="hljs-keyword">\hline</span><br>            Year <span class="hljs-built_in">&amp;</span> theta <span class="hljs-built_in">&amp;</span> <span class="hljs-built_in">$</span>S<span class="hljs-built_in">_</span>1<span class="hljs-built_in">^</span>-<span class="hljs-built_in">$</span> <span class="hljs-built_in">&amp;</span> <span class="hljs-built_in">$</span>S<span class="hljs-built_in">_</span>2<span class="hljs-built_in">^</span>-<span class="hljs-built_in">$</span> <span class="hljs-built_in">&amp;</span> <span class="hljs-built_in">$</span>S<span class="hljs-built_in">_</span>3<span class="hljs-built_in">^</span>-<span class="hljs-built_in">$</span> <span class="hljs-built_in">&amp;</span> <span class="hljs-built_in">$</span>S<span class="hljs-built_in">_</span>4<span class="hljs-built_in">^</span>+<span class="hljs-built_in">$</span> <span class="hljs-built_in">&amp;</span> <span class="hljs-built_in">$</span>S<span class="hljs-built_in">_</span>5<span class="hljs-built_in">^</span>+<span class="hljs-built_in">$</span> <span class="hljs-built_in">&amp;</span> <span class="hljs-built_in">$</span>S<span class="hljs-built_in">_</span>6<span class="hljs-built_in">^</span>+<span class="hljs-built_in">$</span> <span class="hljs-keyword">\\</span><span class="hljs-comment">%表格标题</span><br>            <span class="hljs-keyword">\hline</span><br>            2016 <span class="hljs-built_in">&amp;</span> 1      <span class="hljs-built_in">&amp;</span> 0      <span class="hljs-built_in">&amp;</span> 0 <span class="hljs-built_in">&amp;</span> 0.0001 <span class="hljs-built_in">&amp;</span> 0      <span class="hljs-built_in">&amp;</span> 0      <span class="hljs-built_in">&amp;</span> 0 <span class="hljs-keyword">\\</span><br>            2017 <span class="hljs-built_in">&amp;</span> 0.9997 <span class="hljs-built_in">&amp;</span> 0.0555 <span class="hljs-built_in">&amp;</span> 0 <span class="hljs-built_in">&amp;</span> 0.2889 <span class="hljs-built_in">&amp;</span> 0.1844 <span class="hljs-built_in">&amp;</span> 0.463  <span class="hljs-built_in">&amp;</span> 0 <span class="hljs-keyword">\\</span><br>            2018 <span class="hljs-built_in">&amp;</span> 0.9994 <span class="hljs-built_in">&amp;</span> 0      <span class="hljs-built_in">&amp;</span> 0 <span class="hljs-built_in">&amp;</span> 0.0012 <span class="hljs-built_in">&amp;</span> 0.3269 <span class="hljs-built_in">&amp;</span> 0.7154 <span class="hljs-built_in">&amp;</span> 0 <span class="hljs-keyword">\\</span><br>            2019 <span class="hljs-built_in">&amp;</span> 0.9993 <span class="hljs-built_in">&amp;</span> 0      <span class="hljs-built_in">&amp;</span> 0 <span class="hljs-built_in">&amp;</span> 0      <span class="hljs-built_in">&amp;</span> 0.4325 <span class="hljs-built_in">&amp;</span> 1.0473 <span class="hljs-built_in">&amp;</span> 0 <span class="hljs-keyword">\\</span><br>            2020 <span class="hljs-built_in">&amp;</span> 0.9991 <span class="hljs-built_in">&amp;</span> 0      <span class="hljs-built_in">&amp;</span> 0 <span class="hljs-built_in">&amp;</span> 0      <span class="hljs-built_in">&amp;</span> 0.5046 <span class="hljs-built_in">&amp;</span> 1.2022 <span class="hljs-built_in">&amp;</span> 0 <span class="hljs-keyword">\\</span><br>            2021 <span class="hljs-built_in">&amp;</span> 0.999  <span class="hljs-built_in">&amp;</span> 0      <span class="hljs-built_in">&amp;</span> 0 <span class="hljs-built_in">&amp;</span> 0      <span class="hljs-built_in">&amp;</span> 0.5466 <span class="hljs-built_in">&amp;</span> 1.2827 <span class="hljs-built_in">&amp;</span> 0 <span class="hljs-keyword">\\</span><br>            2022 <span class="hljs-built_in">&amp;</span> 0.9989 <span class="hljs-built_in">&amp;</span> 0.0017 <span class="hljs-built_in">&amp;</span> 0 <span class="hljs-built_in">&amp;</span> 0.3159 <span class="hljs-built_in">&amp;</span> 0.562  <span class="hljs-built_in">&amp;</span> 1.2995 <span class="hljs-built_in">&amp;</span> 0 <span class="hljs-keyword">\\</span><br>            2023 <span class="hljs-built_in">&amp;</span> 0.9989 <span class="hljs-built_in">&amp;</span> 0      <span class="hljs-built_in">&amp;</span> 0 <span class="hljs-built_in">&amp;</span> 0.0109 <span class="hljs-built_in">&amp;</span> 0.5533 <span class="hljs-built_in">&amp;</span> 1.2616 <span class="hljs-built_in">&amp;</span> 0 <span class="hljs-keyword">\\</span><br>            2024 <span class="hljs-built_in">&amp;</span> 0.9989 <span class="hljs-built_in">&amp;</span> 0      <span class="hljs-built_in">&amp;</span> 0 <span class="hljs-built_in">&amp;</span> 0      <span class="hljs-built_in">&amp;</span> 0.5232 <span class="hljs-built_in">&amp;</span> 1.1769 <span class="hljs-built_in">&amp;</span> 0 <span class="hljs-keyword">\\</span><br>            2025 <span class="hljs-built_in">&amp;</span> 0.9989 <span class="hljs-built_in">&amp;</span> 0      <span class="hljs-built_in">&amp;</span> 0 <span class="hljs-built_in">&amp;</span> 0.1009 <span class="hljs-built_in">&amp;</span> 0.4738 <span class="hljs-built_in">&amp;</span> 1.0521 <span class="hljs-built_in">&amp;</span> 0 <span class="hljs-keyword">\\</span><br>            2026 <span class="hljs-built_in">&amp;</span> 0.9991 <span class="hljs-built_in">&amp;</span> 0      <span class="hljs-built_in">&amp;</span> 0 <span class="hljs-built_in">&amp;</span> 0      <span class="hljs-built_in">&amp;</span> 0.4071 <span class="hljs-built_in">&amp;</span> 0.8929 <span class="hljs-built_in">&amp;</span> 0 <span class="hljs-keyword">\\</span><br>            2027 <span class="hljs-built_in">&amp;</span> 0.9992 <span class="hljs-built_in">&amp;</span> 0.0004 <span class="hljs-built_in">&amp;</span> 0 <span class="hljs-built_in">&amp;</span> 0.1195 <span class="hljs-built_in">&amp;</span> 0.3248 <span class="hljs-built_in">&amp;</span> 0.7042 <span class="hljs-built_in">&amp;</span> 0 <span class="hljs-keyword">\\</span><br>            2028 <span class="hljs-built_in">&amp;</span> 0.9994 <span class="hljs-built_in">&amp;</span> 0.0164 <span class="hljs-built_in">&amp;</span> 0 <span class="hljs-built_in">&amp;</span> 0.046  <span class="hljs-built_in">&amp;</span> 0.2287 <span class="hljs-built_in">&amp;</span> 0.4902 <span class="hljs-built_in">&amp;</span> 0 <span class="hljs-keyword">\\</span><br>            2029 <span class="hljs-built_in">&amp;</span> 0.9997 <span class="hljs-built_in">&amp;</span> 0      <span class="hljs-built_in">&amp;</span> 0 <span class="hljs-built_in">&amp;</span> 0.0609 <span class="hljs-built_in">&amp;</span> 0.12   <span class="hljs-built_in">&amp;</span> 0.2545 <span class="hljs-built_in">&amp;</span> 0 <span class="hljs-keyword">\\</span><br>            2030 <span class="hljs-built_in">&amp;</span> 1      <span class="hljs-built_in">&amp;</span> 0      <span class="hljs-built_in">&amp;</span> 0 <span class="hljs-built_in">&amp;</span> 0      <span class="hljs-built_in">&amp;</span> 0      <span class="hljs-built_in">&amp;</span> 0      <span class="hljs-built_in">&amp;</span> 0 <span class="hljs-keyword">\\</span><br>            <span class="hljs-keyword">\hline</span><br>        <span class="hljs-keyword">\end</span>&#123;tabular&#125;<br>    <span class="hljs-keyword">\end</span>&#123;center&#125;<br> <br><span class="hljs-comment">%6. 数学公式</span><br>    <span class="hljs-keyword">\begin</span>&#123;equation&#125;<br>        a<span class="hljs-built_in">^</span>2 = a * a<span class="hljs-keyword">\label</span>&#123;aa&#125;<br>    <span class="hljs-keyword">\end</span>&#123;equation&#125;<br>    <br>    <span class="hljs-keyword">\[</span><br>    <span class="hljs-keyword">\begin</span>&#123;pmatrix&#125;&#123;*&#123;20&#125;c&#125;<br>    &#123;a<span class="hljs-built_in">_</span>&#123;11&#125; &#125; <span class="hljs-built_in">&amp;</span> &#123;a<span class="hljs-built_in">_</span>&#123;12&#125; &#125; <span class="hljs-built_in">&amp;</span> &#123;a<span class="hljs-built_in">_</span>&#123;13&#125; &#125;  <span class="hljs-keyword">\\</span><br>    &#123;a<span class="hljs-built_in">_</span>&#123;21&#125; &#125; <span class="hljs-built_in">&amp;</span> &#123;a<span class="hljs-built_in">_</span>&#123;22&#125; &#125; <span class="hljs-built_in">&amp;</span> &#123;a<span class="hljs-built_in">_</span>&#123;23&#125; &#125;  <span class="hljs-keyword">\\</span><br>    &#123;a<span class="hljs-built_in">_</span>&#123;31&#125; &#125; <span class="hljs-built_in">&amp;</span> &#123;a<span class="hljs-built_in">_</span>&#123;32&#125; &#125; <span class="hljs-built_in">&amp;</span> &#123;a<span class="hljs-built_in">_</span>&#123;33&#125; &#125;  <span class="hljs-keyword">\\</span><br>    <span class="hljs-keyword">\end</span>&#123;pmatrix&#125;<br>    = <span class="hljs-keyword">\frac</span>&#123;&#123;Opposite&#125;&#125;&#123;&#123;Hypotenuse&#125;&#125;<span class="hljs-keyword">\cos</span> <span class="hljs-built_in">^</span>&#123; - 1&#125; <span class="hljs-keyword">\theta</span> <span class="hljs-keyword">\arcsin</span> <span class="hljs-keyword">\theta</span><br>    <span class="hljs-keyword">\]</span><br>    <br>    <span class="hljs-keyword">\[</span><br>    p<span class="hljs-built_in">_</span>&#123;j&#125;=<span class="hljs-keyword">\begin</span>&#123;cases&#125; 0,<span class="hljs-built_in">&amp;</span><span class="hljs-keyword">\text</span>&#123;if <span class="hljs-built_in">$</span>j<span class="hljs-built_in">$</span> is odd&#125;<span class="hljs-keyword">\\</span><br>    r!<span class="hljs-keyword">\,</span>(-1)<span class="hljs-built_in">^</span>&#123;j/2&#125;,<span class="hljs-built_in">&amp;</span><span class="hljs-keyword">\text</span>&#123;if <span class="hljs-built_in">$</span>j<span class="hljs-built_in">$</span> is even&#125;<br>    <span class="hljs-keyword">\end</span>&#123;cases&#125;<br>    <span class="hljs-keyword">\]</span><br>    <br>    <br>    <span class="hljs-keyword">\[</span><br>    <span class="hljs-keyword">\arcsin</span> <span class="hljs-keyword">\theta</span>  =<br>    <span class="hljs-keyword">\mathop</span>&#123;&#123;<span class="hljs-keyword">\int</span><span class="hljs-keyword">\!</span><span class="hljs-keyword">\!</span><span class="hljs-keyword">\!</span><span class="hljs-keyword">\!</span><span class="hljs-keyword">\!</span><span class="hljs-keyword">\int</span><span class="hljs-keyword">\!</span><span class="hljs-keyword">\!</span><span class="hljs-keyword">\!</span><span class="hljs-keyword">\!</span><span class="hljs-keyword">\!</span><span class="hljs-keyword">\int</span>&#125;<span class="hljs-keyword">\mkern</span>-31.2mu<br>        <span class="hljs-keyword">\bigodot</span>&#125;<span class="hljs-keyword">\limits</span><span class="hljs-built_in">_</span><span class="hljs-keyword">\varphi</span><br>    &#123;<span class="hljs-keyword">\mathop</span> &#123;<span class="hljs-keyword">\lim</span> &#125;<span class="hljs-keyword">\limits</span><span class="hljs-built_in">_</span>&#123;x <span class="hljs-keyword">\to</span> <span class="hljs-keyword">\infty</span> &#125; <span class="hljs-keyword">\frac</span>&#123;&#123;n!&#125;&#125;&#123;&#123;r!<span class="hljs-keyword">\left</span>( &#123;n - r&#125;<br>                <span class="hljs-keyword">\right</span>)!&#125;&#125;&#125; <span class="hljs-keyword">\eqno</span> (1)<br>    <span class="hljs-keyword">\]</span><br> <br><span class="hljs-comment">%7. 双图并行</span><br>    <span class="hljs-keyword">\begin</span>&#123;figure&#125;[h]<br>        <span class="hljs-comment">% 一个2*2图片的排列</span><br>        <span class="hljs-keyword">\begin</span>&#123;minipage&#125;[h]&#123;0.5<span class="hljs-keyword">\linewidth</span>&#125;<br>            <span class="hljs-keyword">\centering</span><br>            <span class="hljs-keyword">\includegraphics</span>[width=0.8<span class="hljs-keyword">\textwidth</span>]&#123;./figures/0.jpg&#125;<br>            <span class="hljs-keyword">\caption</span>&#123;Figure example 2&#125;<br>        <span class="hljs-keyword">\end</span>&#123;minipage&#125;<br>        <span class="hljs-keyword">\begin</span>&#123;minipage&#125;[h]&#123;0.5<span class="hljs-keyword">\linewidth</span>&#125;<br>            <span class="hljs-keyword">\centering</span><br>            <span class="hljs-keyword">\includegraphics</span>[width=0.8<span class="hljs-keyword">\textwidth</span>]&#123;./figures/0.jpg&#125;<br>            <span class="hljs-keyword">\caption</span>&#123;Figure example 3&#125;<br>        <span class="hljs-keyword">\end</span>&#123;minipage&#125;<br>    <span class="hljs-keyword">\end</span>&#123;figure&#125;<br> <br><span class="hljs-comment">%8. 单张图片部分</span><br>    <span class="hljs-keyword">\begin</span>&#123;figure&#125;[h]<br>        <span class="hljs-comment">%\small</span><br>        <span class="hljs-keyword">\centering</span><br>        <span class="hljs-keyword">\includegraphics</span>[width=12cm]&#123;./figures/mcmthesis-aaa.eps&#125;<br>        <span class="hljs-keyword">\caption</span>&#123;Figure example 1&#125; <span class="hljs-keyword">\label</span>&#123;fig:aa&#125;<br>    <span class="hljs-keyword">\end</span>&#123;figure&#125;<br> <br><span class="hljs-comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span><br><span class="hljs-keyword">\begin</span>&#123;minipage&#125;&#123;0.5<span class="hljs-keyword">\linewidth</span>&#125;<br>    <span class="hljs-keyword">\begin</span>&#123;tabular&#125;&#123;|c|c|c|&#125;<br>        <span class="hljs-keyword">\hline</span><br>        <span class="hljs-keyword">\multicolumn</span>&#123;2&#125;&#123;|c|&#125;&#123;<span class="hljs-keyword">\multirow</span>&#123;2&#125;&#123;*&#125;&#123;合并&#125;&#125;<span class="hljs-built_in">&amp;</span>测试<span class="hljs-keyword">\\</span><br>        <span class="hljs-keyword">\cline</span>&#123;3-3&#125;<br>        <span class="hljs-keyword">\multicolumn</span>&#123;2&#125;&#123;|c|&#125;&#123;&#125;<span class="hljs-built_in">&amp;</span> 0.9997  <span class="hljs-keyword">\\</span><br>        <span class="hljs-keyword">\hline</span><br>        2019 <span class="hljs-built_in">&amp;</span> 0.9993 <span class="hljs-built_in">&amp;</span> 0 <span class="hljs-keyword">\\</span><br>        <span class="hljs-keyword">\hline</span><br>    <span class="hljs-keyword">\end</span>&#123;tabular&#125;<br><span class="hljs-keyword">\end</span>&#123;minipage&#125;<br><span class="hljs-keyword">\begin</span>&#123;minipage&#125;&#123;0.5<span class="hljs-keyword">\linewidth</span>&#125;<br>    <span class="hljs-keyword">\begin</span>&#123;tabular&#125;&#123;c|ccc&#125;<br>        <span class="hljs-keyword">\hline</span><br>        年份 <span class="hljs-built_in">&amp;</span> <span class="hljs-keyword">\multicolumn</span>&#123;3&#125;&#123;c&#125;&#123;指标&#125;<span class="hljs-keyword">\\</span><br>        <span class="hljs-keyword">\hline</span><br>        <span class="hljs-keyword">\multirow</span>&#123;3&#125;&#123;*&#125;&#123;合并&#125;<span class="hljs-built_in">&amp;</span>2017 <span class="hljs-built_in">&amp;</span> 0.9997 <span class="hljs-built_in">&amp;</span> 0.0555 <span class="hljs-keyword">\\</span><br>        <span class="hljs-built_in">&amp;</span>2018 <span class="hljs-built_in">&amp;</span> 0.9994 <span class="hljs-built_in">&amp;</span> 0      <span class="hljs-keyword">\\</span><br>        <span class="hljs-built_in">&amp;</span>2019 <span class="hljs-built_in">&amp;</span> 0.9993 <span class="hljs-built_in">&amp;</span> 0      <span class="hljs-keyword">\\</span><br>        <span class="hljs-keyword">\hline</span><br>    <span class="hljs-keyword">\end</span>&#123;tabular&#125;<br><span class="hljs-keyword">\end</span>&#123;minipage&#125;<br>    <span class="hljs-keyword">\begin</span>&#123;table&#125;[h]<br>    <span class="hljs-keyword">\centering</span>  <br>    <span class="hljs-keyword">\begin</span>&#123;Large&#125;<br>        <span class="hljs-keyword">\begin</span>&#123;tabular&#125;&#123;p&#123;4cm&#125; p&#123;8cm&#125; &lt; &#123;<span class="hljs-keyword">\centering</span>&#125;&#125;<br>            <span class="hljs-keyword">\hline</span><br>            院<span class="hljs-keyword">\qquad</span> 系: <span class="hljs-built_in">&amp;</span> 信息工程学院 <span class="hljs-keyword">\\</span><br>            <span class="hljs-keyword">\hline</span><br>            团队名称: <span class="hljs-built_in">&amp;</span> PlantBook Team <span class="hljs-keyword">\\</span><br>            <span class="hljs-keyword">\hline</span><br>            分<span class="hljs-keyword">\qquad</span> 组: <span class="hljs-built_in">&amp;</span> 第0组1号 <span class="hljs-keyword">\\</span><br>            <span class="hljs-keyword">\hline</span><br>            日<span class="hljs-keyword">\qquad</span> 期: <span class="hljs-built_in">&amp;</span> 2017年10月28日 <span class="hljs-keyword">\\</span><br>            <span class="hljs-keyword">\hline</span><br>            指导教师: <span class="hljs-built_in">&amp;</span> 吱吱吱<span class="hljs-keyword">\\</span><br>            <span class="hljs-keyword">\hline</span><br>        <span class="hljs-keyword">\end</span>&#123;tabular&#125;<br>    <span class="hljs-keyword">\end</span>&#123;Large&#125;<br><span class="hljs-keyword">\end</span>&#123;table&#125;<br><span class="hljs-keyword">\ctexset</span>&#123;<br>    section=&#123;<br>        format+=<span class="hljs-keyword">\heiti</span> <span class="hljs-keyword">\raggedright</span>,<br>        name=&#123;,、&#125;,<br>        number=<span class="hljs-keyword">\chinese</span>&#123;section&#125;,<br>        beforeskip=1.0ex plus 0.2ex minus .2ex,<br>        afterskip=1.0ex plus 0.2ex minus .2ex,<br>        aftername=<span class="hljs-keyword">\hspace</span>&#123;0pt&#125;<br>    &#125;,<br>&#125;<br>    <span class="hljs-keyword">\begin</span>&#123;table&#125;[h]<br>    <span class="hljs-keyword">\centering</span><br>    <span class="hljs-keyword">\begin</span>&#123;Large&#125;<br>        <span class="hljs-keyword">\begin</span>&#123;tabular&#125;&#123;p&#123;3cm&#125; p&#123;7cm&#125;&lt;&#123;<span class="hljs-keyword">\centering</span>&#125;&#125;<br>            院  <span class="hljs-keyword">\qquad</span>  系: <span class="hljs-built_in">&amp;</span> 信息工程学院           <span class="hljs-keyword">\\</span> <span class="hljs-keyword">\cline</span>&#123;2-2&#125;<br>        <span class="hljs-keyword">\end</span>&#123;tabular&#125;<br>    <span class="hljs-keyword">\end</span>&#123;Large&#125;     <br><span class="hljs-keyword">\end</span>&#123;table&#125;<br><span class="hljs-keyword">\thispagestyle</span>&#123;empty&#125;<br><span class="hljs-keyword">\newpage</span><br><span class="hljs-keyword">\thispagestyle</span>&#123;empty&#125;<br><span class="hljs-keyword">\tableofcontents</span><br><span class="hljs-keyword">\thispagestyle</span>&#123;empty&#125;<br><span class="hljs-keyword">\newpage</span><br><span class="hljs-keyword">\setcounter</span>&#123;page&#125;&#123;1&#125;<br><span class="hljs-comment">% 9. 代码</span><br> <br><span class="hljs-keyword">\usepackage</span>&#123;listings&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;xcolor&#125;<br><span class="hljs-keyword">\lstset</span>&#123;<br>    numbers=left, <br>    numberstyle= <span class="hljs-keyword">\tiny</span>, <br>    keywordstyle= <span class="hljs-keyword">\color</span>&#123; blue!70&#125;,<br>    commentstyle= <span class="hljs-keyword">\color</span>&#123;red!50!green!50!blue!50&#125;, <br>    frame=shadowbox, <span class="hljs-comment">% 阴影效果</span><br>    rulesepcolor= <span class="hljs-keyword">\color</span>&#123; red!20!green!20!blue!20&#125; ,<br>    escapeinside=``, <span class="hljs-comment">% 英文分号中可写入中文</span><br>    xleftmargin=2em,xrightmargin=2em, aboveskip=1em,<br>    basicstyle=<span class="hljs-keyword">\footnotesize</span>,<br>    framexleftmargin=2em<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>注意一定要保存。每次进行修改后也一定要保存、才能显示修改后的内容</strong></p></li><li><p>之后在右上角找到如下的图标， 点击第二个三角形运行</p></li><li><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h89n9p4221j309q020q2q.jpg" alt="截屏2022-11-18 21.59.15"></p></li><li><p>如果没有就鼠标右键选择<code>build latex project</code></p></li><li><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h89n9qtygbj30jk0lomyi.jpg" alt="截屏2022-11-18 22.01.50" style="zoom:50%;" /></li><li><p>然后点击第三个如下第三个图标进行预览或者直接在工作区里面选择pdf文件进行浏览<img src="https://tva1.sinaimg.cn/large/008vxvgGly1h89n9wkcixj309q020q2q.jpg" alt="截屏2022-11-18 21.59.15"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>latex</category>
      
    </categories>
    
    
    <tags>
      
      <tag>latex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C数据结构--链表</title>
    <link href="/2022/11/17/C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/11/17/C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="何为链表"><a href="#何为链表" class="headerlink" title="何为链表"></a>何为链表</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>链表，就是一种在计算机实际内存里面非连续，但是每个元素可以通过链表里面的指针依次链接顺序，实现的一种线性存储结构。<img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8841fksroj30nd04aq33.jpg" alt="img"></p><h3 id="构成："><a href="#构成：" class="headerlink" title="构成："></a>构成：</h3><ul><li>节点（在运行时动态生成）<ul><li>数据域（存储数据元素）</li><li>指针域（指向下一个节点）</li></ul></li></ul><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h883yehqqqj315609zabn.jpg" alt="img"></p><p>链表由一个个节点构成，每个节点都会写成结构体类型，从而存放数据域（对象可以是多个）和指针域。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 节点的表示</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>  <span class="hljs-type">char</span> data;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span><br>&#125;linknode;<br></code></pre></td></tr></table></figure><p><strong>对于双向链表，就是指针域里面多了一个指向前一个节点的指针</strong></p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8849g85hxj314007ymya.jpg" alt="img"></p><h2 id="创建链表"><a href="#创建链表" class="headerlink" title="创建链表"></a>创建链表</h2><ol><li>先创建一个节点，这个节点的指针域为<code>NULL</code></li><li>然后再创建一个节点，让上一个节点的指针域指向这个节点的地址，这个节点的指针域为<code>NULL</code></li><li>以此类推…</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-comment">// 定义节点</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>  <span class="hljs-type">int</span> data; <span class="hljs-comment">// 数据域</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">// 指针域</span><br>&#125;linknode;<br><br><span class="hljs-comment">// 链表的创建</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">creat_linknode</span><span class="hljs-params">(linknode **p_head, linknode *p_new)</span> &#123;<br>  linknode *p_mov = *p_head;<span class="hljs-comment">// **p_head作为储存第一个节点指针的指针</span><br>  <span class="hljs-keyword">if</span> (*p_head == <span class="hljs-literal">NULL</span>) &#123;<br>    *p_head = p_new;<br>    p_new -&gt; next = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">// 第一次在空的链表里面创建第一个节点时</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">while</span> (p_mov -&gt; next != <span class="hljs-literal">NULL</span>) &#123;<br>      p_mov = p_mov -&gt; next;<span class="hljs-comment">// p_mov从第一个节点一直移动到最后一个节点</span><br>    &#125;<br>    <br>    p_mov -&gt; next = p_new;<br>    p_new -&gt; next = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">// 将最后一个节点和新建的节点连接起来</span><br>  &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  linknode *head = <span class="hljs-literal">NULL</span>;<br>  linknode *p_new = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-type">int</span> num, i;<br>  <br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入链表的初始个数：&quot;</span>);<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, &amp;num);<br>  <br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br>    p_new = (linknode*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(linknode));<span class="hljs-comment">// 为新节点开辟一块新空间</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入一个字符：&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, &amp;p_new -&gt; data);<span class="hljs-comment">// 传入数据域</span><br>    <br>    creat_linknode(&amp;head, p_new);<span class="hljs-comment">// 将新节点加入列表</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="链表遍历"><a href="#链表遍历" class="headerlink" title="链表遍历"></a>链表遍历</h2><ol><li>让指针指向第一个节点，输出第一个节点的数据域</li><li>之后通过第一个节点的指针域让指针指向下一个节点</li><li>以此遍历…</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 链表的遍历</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">link_print</span><span class="hljs-params">(linknode *head)</span> &#123;<br>  linknode *p_mov;<br>  p_mov = head;<span class="hljs-comment">// 定义一个新的指针，防止head被改变;</span><br>  <br>  <span class="hljs-keyword">while</span> (p_mov != <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-comment">// 先打印指针当前指向的节点的数据域</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;int=%d&quot;</span>, p_mov -&gt; next);<br>    <br>    <span class="hljs-comment">// 指针后移，保存下一个节点的地址</span><br>    p_mov = p_mov -&gt; next;<span class="hljs-comment">// 最后p_mov就变成了NULL</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="链表的释放"><a href="#链表的释放" class="headerlink" title="链表的释放"></a>链表的释放</h2><ol><li>重新定义一个指针，让这个指针指向head保存节点的地址，让head后移，然后释放新建指针对应的节点</li><li>以此类推…</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 链表的释放</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">link_free</span><span class="hljs-params">(linknode **head)</span> &#123;<br>  <span class="hljs-comment">// 定义一个指针变量保存头节点的地址</span><br>  linknode *pb = *head;<br>  <br>  <span class="hljs-keyword">while</span> (*p_head != <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-comment">// 先保存p_head指向节点的地址</span><br>    pb = *p_head;<br>    <span class="hljs-comment">// 将head指向下一个节点</span><br>    *p_head = (*p_head) -&gt; next;<br>    <span class="hljs-comment">// 释放节点并防止野指针</span><br>    <span class="hljs-built_in">free</span>(pb);<br>    pb = <span class="hljs-literal">NULL</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="链表节点的查找"><a href="#链表节点的查找" class="headerlink" title="链表节点的查找"></a>链表节点的查找</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 链表节点的查找</span><br><span class="hljs-comment">// 按照数据域里面的某个数据进行查找</span><br>linknode *<span class="hljs-title function_">link_search</span><span class="hljs-params">(linknode *head, <span class="hljs-type">int</span> num)</span> &#123;<br>  linknode *p_mov;<br>  <span class="hljs-comment">// 定义的指针变量保存第一个节点的地址</span><br>  p_mov = head;<br>  <span class="hljs-comment">// 循环遍历指针</span><br>  <span class="hljs-keyword">while</span> (p_mov != <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-keyword">if</span> (p_mov -&gt; data == num) &#123;<br>      <span class="hljs-keyword">return</span> p_mov;<br>    &#125;<br>    p_mov = p_mov -&gt; next;<br>  &#125;<br>  <span class="hljs-comment">// 没有找到则返回空</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="链表节点的删除"><a href="#链表节点的删除" class="headerlink" title="链表节点的删除"></a>链表节点的删除</h2><ul><li>如果删除的是第一个节点，那么就让保存第一个节点地址的头指针指向下一个节点即可</li><li>如果删除的是中间的节点，那么就让中间节点的前一个节点的指针域指向中间节点下一个节点的地址即可</li><li>如果链表为空，则不需要删除</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 链表节点的删除</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">link_delete</span><span class="hljs-params">(linknode **head, <span class="hljs-type">int</span> num)</span> &#123;<br>  linknode *pb, *pf;<br>  pb = pf = *head;<br>  <span class="hljs-keyword">if</span> (*head == <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;链表为空，没有你要删的节点&quot;</span>);  <span class="hljs-comment">// 链表为空的情况时</span><br>  <span class="hljs-keyword">return</span> ;<br>  &#125;<br>  <span class="hljs-keyword">while</span> ((pb -&gt; data != num) &amp;&amp; (pb -&gt; next != <span class="hljs-literal">NULL</span>)) &#123;<br>    pf = pb;<br>    pb = pb -&gt; next;<span class="hljs-comment">// 循环找要删除的节点</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (pb -&gt; data == num) &#123;<span class="hljs-comment">// 找到了一个节点的data与num相同</span><br>    <span class="hljs-keyword">if</span> (pb == *head) &#123;<span class="hljs-comment">// 要删除的节点是头节点</span><br>      <span class="hljs-comment">// 让保存头节点的指针保存下一个节点的地址</span><br>      *head = pb -&gt; next;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 前一个节点的指针指向中间节点下一个节点的地址</span><br>      pf -&gt; next = pb -&gt; next;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 释放空间并防止野指针</span><br>    <span class="hljs-built_in">free</span>(pb);<br>    pb = <span class="hljs-literal">NULL</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;没有你要删除的节点\n&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="链表中插入一个节点"><a href="#链表中插入一个节点" class="headerlink" title="链表中插入一个节点"></a>链表中插入一个节点</h2><ul><li>如果链表中没有节点，则插入的就是第一个节点</li><li>如果插入节点的数值最小，则作为头节点</li><li>如果插入节点的数值在中间位置，则找到前一个，插入到它后面，让前一个的指针域指向这个新插入节点的地址，新插入节点的指针域指向下一个节点的地址</li><li>如果新插入的节点的数值最大，则插入到最后</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 链表的插入</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">link_insert</span><span class="hljs-params">(linknode **head, linknode *p_new)</span> &#123;<br>  linknode *pb, *pf;<br>  pb = pf = *head;<br>  <span class="hljs-keyword">if</span> (*head == <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-comment">// 链表为空链表</span><br>    *head = p_new;<br>    p_new -&gt; next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> ;<br>  &#125;<br>  <span class="hljs-keyword">while</span> ((p_new -&gt; data &gt;= p -&gt; data) &amp;&amp; (pb -&gt; next != <span class="hljs-literal">NULL</span>)) &#123;<br>    pf = pb;<br>    pb = pb -&gt; next;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (p_new -&gt; data  &lt; pb -&gt; data) &#123;<span class="hljs-comment">// 新来的节点data比pb小，就插在pb前面</span><br>    <span class="hljs-keyword">if</span> (pb == *head) &#123;<span class="hljs-comment">// pb是头节点的情况下</span><br>      p_new -&gt; next = *head;      <br>      *head = p_new;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// pb在中间节点</span><br>      pf -&gt; next = p_new;<br>      p_new -&gt; next = pb;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 没有找到比p_new的data大的节点，就把p_new插到最后面</span><br>    pb -&gt; next = p_new;<br>    p_new -&gt; next = <span class="hljs-literal">NULL</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="链表排序"><a href="#链表排序" class="headerlink" title="链表排序"></a>链表排序</h2><ul><li>如果链表为空或者只有一个节点，就不需要排序</li><li>先将第一个节点与后面所有的节点对比数据域，只要有比第一个节点数据域小的，则交换位置</li><li>拿到新的第一个节点对比后面，依此类推</li><li>最后开始第二个节点，依次类推</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 链表的排序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">link_order</span><span class="hljs-params">(linknode *head)</span> &#123;<br>  linknode *pb, *pf, temp;<br>  pf = head;<br>  <br>  <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-comment">// 没有节点</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;链表为空，不用排序\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> ;<br>  &#125; <br>  <span class="hljs-keyword">if</span> (head -&gt; next == <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-comment">// 一个节点</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;只有一个节点，不用排序\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> ;<br>  &#125;<br>  <span class="hljs-keyword">while</span> (pf -&gt; next != <span class="hljs-literal">NULL</span>) &#123;<br>    pb = pf -&gt; next;<br>    <span class="hljs-keyword">while</span> (pb != <span class="hljs-literal">NULL</span>) &#123;<br>      <span class="hljs-keyword">if</span> (pf -&gt; data &gt; pb -&gt; data) &#123;<br>        <span class="hljs-comment">// 交换对应的数据域</span><br>        temp = *pb;<br>        *pb = *pf;<br>        *pf = temp;<br>        <br>        <span class="hljs-comment">// 交换对应的指针域</span><br>        temp.next = pb -&gt; next;<br>        pb -&gt; next = pf -&gt; next;<br>        pf -&gt; next = temp.next;<br>      &#125;<br>      pb = pb -&gt; next;<br>    &#125;<br>    pf = pf -&gt; next;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双向链表的创建与遍历"><a href="#双向链表的创建与遍历" class="headerlink" title="双向链表的创建与遍历"></a>双向链表的创建与遍历</h2><ol><li>创建一个节点作为头指针，将两个指针域都保存为<code>NULL</code></li><li>找到链表中的最后一个节点，让最后一个节点的指针域指向新插入节点的地址，让新加入节点的两个指针域，一个指向上一个节点的地址，一个为<code>NULL</code></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-comment">// 定义双向链表的节点</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> &#123;</span><br>  <span class="hljs-comment">// 数据域</span><br>  <span class="hljs-type">int</span> num;        <span class="hljs-comment">// 学号</span><br>  <span class="hljs-type">int</span> score;      <span class="hljs-comment">// 分数</span><br>  <span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];  <span class="hljs-comment">// 姓名</span><br><br>  <span class="hljs-comment">// 指针域</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> *<span class="hljs-title">front</span>;</span>    <span class="hljs-comment">// 保存上一个指针的地址</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> *<span class="hljs-title">next</span>;</span>     <span class="hljs-comment">// 指向下一个节点的地址</span><br>&#125;STU;<br><br><span class="hljs-comment">// 新建节点</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">double_link_creat</span><span class="hljs-params">(STU **head, STU *p_new)</span> &#123;<br>  STU *p_mov = *head;<br>  <span class="hljs-comment">// 新增节点</span><br>  <span class="hljs-keyword">if</span> (*head == <span class="hljs-literal">NULL</span>) &#123;        <span class="hljs-comment">// 当第一次加入节点，整个链表为空的时候</span><br>    *head = p_new;<br>    p_new -&gt; front = <span class="hljs-literal">NULL</span>;<br>    p_new -&gt; next = <span class="hljs-literal">NULL</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;                  <span class="hljs-comment">// 在链表最后一个节点后面加入节点</span><br>    <span class="hljs-keyword">while</span> (p_mov -&gt; next != <span class="hljs-literal">NULL</span>) &#123;<br>      p_mov = p_mov -&gt; next;    <span class="hljs-comment">// 找到原有链表的最后一个节点</span><br>    &#125;<br>    p_mov -&gt; next = p_new;      <span class="hljs-comment">// 将新节点插入到链表里面去</span><br>    p_new -&gt; front = p_mov;<br>    p_new -&gt; next = <span class="hljs-literal">NULL</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 打印双向链表(正向逆向都打印一遍)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">double_link_print</span><span class="hljs-params">(STU *head)</span> &#123;<br>  STU *pb;<br>  pb = head;<br>  <span class="hljs-keyword">while</span> (pb -&gt; next != <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;num=%d, score=%d, name=%s\n&quot;</span>, pb -&gt; num, pb -&gt; score, pb -&gt; name);<br>    pb = pb -&gt; next;<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;num=%d, score=%d, name=%s\n&quot;</span>, pb -&gt; num, pb -&gt; score, pb -&gt; name);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;***************************\n&quot;</span>);<br><br>  <span class="hljs-keyword">while</span> (pb != <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;num=%d, score=%d, name=%s\n&quot;</span>, pb -&gt; num, pb -&gt; score, pb -&gt; name);<br>    pb = pb -&gt; front;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 双向链表的节点删除</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">double_link_delete</span><span class="hljs-params">(STU **head, <span class="hljs-type">int</span> num)</span> &#123;<br>  STU *pb, *pf;<br>  pb = *head;<br>  <span class="hljs-keyword">if</span> (*head = <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;此链表为空，没有要删除的节点\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> ;<br>  &#125;<br>  <span class="hljs-keyword">while</span> ((pb -&gt; num != num) &amp;&amp; (pb -&gt; next != <span class="hljs-literal">NULL</span>)) &#123;<br>    pb = pb -&gt; next;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (pb -&gt; num == num) &#123;       <span class="hljs-comment">// 找到了要删除的节点</span><br>    <span class="hljs-comment">// 如果节点是头节点</span><br>    <span class="hljs-keyword">if</span> (pb == *head) &#123;<br>      <span class="hljs-keyword">if</span> ((*head) -&gt; next == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-comment">// 如果链表只有一个节点</span><br>        *head = pb -&gt; next;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 有多个节点的情况</span><br>        *head = pb -&gt; next;<br>        (*head) -&gt; front = <span class="hljs-literal">NULL</span>;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 如果节点在其它地方</span><br>      <span class="hljs-keyword">if</span> (pb -&gt; next != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-comment">// 删除中间节点</span><br>        pf = pb -&gt; front;   <span class="hljs-comment">// 让pf保存前一个节点的地址</span><br>        pf -&gt; next = pb -&gt; next;    <span class="hljs-comment">// 让前一个节点的next保存后一个节点的地址</span><br>        (pb -&gt; next) -&gt; front = pf;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 删除尾节点</span><br>        pf = pb -&gt; front;<br>        pf -&gt; next = <span class="hljs-literal">NULL</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 释放内存</span><br>    <span class="hljs-built_in">free</span>(pb);<br>    pb = <span class="hljs-literal">NULL</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 没找到</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;没有你要找的节点\n&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  STU *head = <span class="hljs-literal">NULL</span>;<br>  STU *p_new = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-type">int</span> num, i;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入链表的节点数：&quot;</span>);<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;num);<br><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br>    p_new = (STU *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(STU));      <span class="hljs-comment">// 开辟一个内存空间</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入学号、得分、姓名：&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %s&quot;</span>, &amp;p_new -&gt; num, &amp;p_new -&gt; score, &amp;p_new -&gt; name);<br>    double_link_creat(&amp;head, p_new); <br>  &#125;<br>  double_link_print(head);<br><br>  <span class="hljs-comment">// 双向链表删除节点操作</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入你要删除的节点的num\n&quot;</span>);<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;num);<br>  double_link_delete(&amp;head, num);<br>  double_link_print(head);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于numpy和pillow的字符画</title>
    <link href="/2022/10/30/%E5%9F%BA%E4%BA%8Enumpy%E5%92%8Cpillow%E7%9A%84%E5%AD%97%E7%AC%A6%E7%94%BB/"/>
    <url>/2022/10/30/%E5%9F%BA%E4%BA%8Enumpy%E5%92%8Cpillow%E7%9A%84%E5%AD%97%E7%AC%A6%E7%94%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="Python基于numpy和pillow生成字符画"><a href="#Python基于numpy和pillow生成字符画" class="headerlink" title="Python基于numpy和pillow生成字符画"></a>Python基于numpy和pillow生成字符画</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>日常生活中，我们看到的彩色图像，一般都是由<strong>RGB模式</strong>组成的，即红、绿、蓝三原色</p><p>而当图像从彩色变成灰色时（比如素描），我们依然能够判断出这幅灰色图像的内容，这是我们依靠<strong>灰度值的不同</strong>去进行区分的</p><p>那么，对于字符画，我们是否也可以去根据字符的密集程度来体现灰度值，从而将一幅灰度图转化为字符画</p><h2 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h2><p>首先，对每个字符的线条的密集程度进行一个排序，用于生成字符画时的明暗区分。在这里我用到的替代字符为<code>MNHQ$OC?7&gt;!:-; </code><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h7jjcpyb8vj3086092750.jpg" alt="在这里插入图片描述"></p><p>字符画的基础为单色图。所以我们没有必要去研究彩色图片，只需要将彩色图转化为灰度图，根据灰色图片中每个像素的灰度值将对应像素替换为对应的字符</p><p>因为一般，替代字符一般是高度&gt;宽度的，并且每行之间都有一定的间隙，这就导致了转化后的字符图可能会出现拉伸，那么为了消除这种拉伸，我们可以在转化之前，将灰度图的宽度进行拉伸，用于抵消</p><p>然后，生成一个和灰度对应的数组pixels，遍历pixels中的每个像素，根据像素的灰度获取字符并进行拼接，最后返回结果</p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><pre><code class=" mermaid">graph TD;设置字符串chars用于区分不同灰度 --&gt;通过PIL的Image包读取img图片并进行,压缩,宽度拉伸 --&gt;将img图片转化为灰图 --&gt;使用numpy生成与img相同的数组pixels --&gt;定义空串result --&gt;遍历循环pixels中的像素点,获取像素灰度对应的字符,并将该字符拼接到result,一行遍历完成后拼接换行符 --&gt;返回result;</code></pre><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">character_painting</span>(<span class="hljs-params">path, out_path, widen, chars</span>):<br>    img = Image.<span class="hljs-built_in">open</span>(path)  <span class="hljs-comment"># 拿到图片</span><br>    img_width, img_height = img.size   <span class="hljs-comment"># 拿取宽、高</span><br>    img_width, img_height = img_width // <span class="hljs-number">25</span>, img_height // <span class="hljs-number">25</span>   <span class="hljs-comment"># 压缩图片</span><br>    img_width = <span class="hljs-built_in">int</span>(img_height * widen)     <span class="hljs-comment"># 自定义拉伸效果</span><br>    img = img.resize((img_width, img_height), Image.Resampling.LANCZOS)  <span class="hljs-comment"># 修改图片的尺寸</span><br>    img = img.convert(<span class="hljs-string">&quot;L&quot;</span>)      <span class="hljs-comment"># 转成灰度图</span><br>    pilexs = np.array(img)      <span class="hljs-comment"># 生成数组</span><br>    N = <span class="hljs-built_in">len</span>(chars)<br>    step = <span class="hljs-number">255</span> // N<br>    result = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(img_height):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(img_width):<br>            index = pilexs[i][j] // step<br>            result += chars[index]<br>        result += <span class="hljs-string">&quot;\n&quot;</span><br><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(out_path, <span class="hljs-string">&quot;w&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(result)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    character_painting(<span class="hljs-string">&quot;/Users/zhanghaoyu/Desktop/j.jpeg&quot;</span>,<br>                       <span class="hljs-string">&quot;/Users/zhanghaoyu/Desktop/new_static.txt&quot;</span>,<br>                       widen=<span class="hljs-number">1.8</span>,<br>                       chars=<span class="hljs-string">&quot;MNHQ$OC?7&gt;!:-; &quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
      <category>字符画</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符画</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>requests网络请求模块</title>
    <link href="/2022/10/30/requests%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%A8%A1%E5%9D%97/"/>
    <url>/2022/10/30/requests%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<p><code>requests</code>是可以模仿browser来发送请求并获取响应信息，能够自动解压网页内容的模块</p><h2 id="requests模块安装"><a href="#requests模块安装" class="headerlink" title="requests模块安装"></a><code>requests</code>模块安装</h2><p>在命令行里面输入:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip3 install requests<br></code></pre></td></tr></table></figure><h2 id="requests模块使用"><a href="#requests模块使用" class="headerlink" title="requests模块使用"></a><code>requests</code>模块使用</h2><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入模块</span><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-comment"># 定义请求地址</span><br>url = <span class="hljs-string">&quot;https://www.baidu.com&quot;</span><br><span class="hljs-comment"># 发送GET请求方法获取响应信息</span><br>response = requests.get(url)<br><span class="hljs-comment"># 获取响应的html内容</span><br>html = response.text<br></code></pre></td></tr></table></figure><h3 id="response常用属性"><a href="#response常用属性" class="headerlink" title="response常用属性"></a>response常用属性</h3><table><thead><tr><th align="center"><strong>response.text</strong></th><th align="center"><strong>返回str类型的响应内容</strong></th></tr></thead><tbody><tr><td align="center"><strong>response.content</strong></td><td align="center"><strong>返回bytes类型的响应内容</strong></td></tr><tr><td align="center"><strong>response.status_code</strong></td><td align="center"><strong>返回响应状态码</strong></td></tr><tr><td align="center"><strong>response.request.headers</strong></td><td align="center"><strong>返回请求头</strong></td></tr><tr><td align="center"><strong>response.headers</strong></td><td align="center"><strong>返回响应头</strong></td></tr><tr><td align="center"><strong>response.cookies</strong></td><td align="center"><strong>返回响应的RequestsCookieJar对象</strong></td></tr></tbody></table><h3 id="response-content-转换-str-类型"><a href="#response-content-转换-str-类型" class="headerlink" title="response.content 转换 str 类型"></a>response.content 转换 str 类型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br>url = <span class="hljs-string">&quot;https://www.baidu.com&quot;</span><br><br>response = requests.get(url)<br><br><span class="hljs-comment"># 获取字节数据</span><br>content = response.content<br><span class="hljs-comment"># 将bytes类型的响应消息转换为str类型</span><br>html = content.decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="response-cookies-操作"><a href="#response-cookies-操作" class="headerlink" title="response.cookies 操作"></a>response.cookies 操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 返回RequestsCookieJar对象</span><br>cookies = response.cookies<br><span class="hljs-comment"># RequestsCookieJar 转 dict</span><br>requests.utils.dict_from_cookiejar(cookies)<br><span class="hljs-comment"># dict 转 cookiejar</span><br>requests.utils.cookiejar_from_dict(cookies)<br><span class="hljs-comment"># 对 cookie 进行操作，把一个字典添加到 cookiejar 中</span><br>requests.utils.add_dict_to_cookiejar(被添加<span class="hljs-built_in">dict</span>的cookies, 添加的<span class="hljs-built_in">dict</span>)<br></code></pre></td></tr></table></figure><h3 id="发送-GET-请求"><a href="#发送-GET-请求" class="headerlink" title="发送 GET 请求"></a>发送 GET 请求</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入模块</span><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-comment"># 定义请求地址</span><br>url = <span class="hljs-string">&quot;https://www.baidu.com&quot;</span><br><span class="hljs-comment"># 定义自定义请求头</span><br>headers = &#123;<br>  <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36&quot;</span><br>&#125;<br><span class="hljs-comment"># 定义 GET 请求参数</span><br>params = &#123;<br>  <span class="hljs-string">&quot;kw&quot;</span>: <span class="hljs-string">&quot;hello&quot;</span><br>&#125;<br><span class="hljs-comment"># 使用GET请求参数发送请求内容</span><br>response = requests.get(url, headers=headers, params=params)<br><span class="hljs-comment"># 返回响应的 html 内容</span><br>html = response.text<br></code></pre></td></tr></table></figure><h3 id="发送-POST-请求"><a href="#发送-POST-请求" class="headerlink" title="发送 POST 请求"></a>发送 POST 请求</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入模块</span><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-comment"># 定义请求地址</span><br>url = <span class="hljs-string">&quot;https://www.baidu.com&quot;</span><br><span class="hljs-comment"># 定义自定义请求头</span><br>headers = &#123;<br>  <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36&quot;</span><br>&#125;<br><span class="hljs-comment"># 定义 POST 请求参数</span><br>data = &#123;<br>  <span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;username&quot;</span>,<br>  <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;password&quot;</span><br>&#125;<br><span class="hljs-comment"># 使用 POST 请求参数发送请求</span><br>response = requests.post(url, headers=headers, data=data)<br><span class="hljs-comment"># 返回响应的 html 内容</span><br>html = response.text<br></code></pre></td></tr></table></figure><h3 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入模块</span><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-comment"># 下载图片地址</span><br>url = <span class="hljs-string">&quot;https://pic-go-img.oss-cn-hangzhou.aliyuncs.com/202202231717952.jpg&quot;</span><br><span class="hljs-comment"># 发送请求获取响应</span><br>response = requests.get(url)<br><span class="hljs-comment"># 保存图片</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/Users/zhanghaoyu/Desktop/photo.jpg&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> f:<br>  f.write(response.content)<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><strong>保存图片时的后缀名必须和下载图片的后缀名一致</strong></li><li><strong>保存必须使用<code>response.content</code>来保存图片</strong></li></ul><h2 id="使用代理服务器"><a href="#使用代理服务器" class="headerlink" title="使用代理服务器"></a>使用代理服务器</h2><ul><li><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>让服务器以为不是同一个客户端在发送请求</li><li>隐藏我们的真实地址，防止被追究责任</li></ul></li><li><h3 id="使用代理的过程"><a href="#使用代理的过程" class="headerlink" title="使用代理的过程"></a>使用代理的过程<a href="https://github.com/Kr1s77/Python-crawler-tutorial-starts-from-zero/blob/master/images/%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E7%9A%84%E8%BF%87%E7%A8%8B.png"><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h7lagdwlwbj317i0b0ta7.jpg" alt="img"></a></h3></li><li><h3 id="代理分类"><a href="#代理分类" class="headerlink" title="代理分类"></a>代理分类</h3><ul><li>透明代理（可以隐藏IP地址，但是还是能查到你是谁）</li><li>匿名代理（别人只知道你用了代理，但是不知道你是谁）</li><li>混淆代理（别人还是能知道你用了代理，但是会得到一个假的IP地址，混淆的更真实）</li><li>高匿代理（最好的选择，让别人无法知道你在使用代理）</li></ul></li></ul><p><strong>注：</strong></p><p>从使用的协议：代理IP可以分为http代理，https代理，socket代理等，使用时需要根据抓取网站等协议来选择</p><h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入模块</span><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-comment"># 定义请求地址</span><br>url = <span class="hljs-string">&quot;https://www.baidu.com&quot;</span><br><span class="hljs-comment"># 定义自定义请求头</span><br>headers = &#123;<br>  <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36&quot;</span><br>&#125;<br><span class="hljs-comment"># 定义代理服务器</span><br>proxies = &#123;<br>  <span class="hljs-string">&quot;http&quot;</span>:<span class="hljs-string">&quot;http://IP地址:端口号&quot;</span>,<br>  <span class="hljs-string">&quot;https&quot;</span>:<span class="hljs-string">&quot;https://IP地址:端口号&quot;</span><br>&#125;<br><span class="hljs-comment"># 使用 POST 请求参数发送请求</span><br>response = requests.post(url, headers=headers, proxies=proxies)<br></code></pre></td></tr></table></figure><h2 id="发送请求时携带Cookies"><a href="#发送请求时携带Cookies" class="headerlink" title="发送请求时携带Cookies"></a>发送请求时携带Cookies</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入模块</span><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-comment"># 定义请求地址</span><br>url = <span class="hljs-string">&quot;https://www.baidu.com&quot;</span><br><span class="hljs-comment"># 定义自定义请求头</span><br>headers = &#123;<br>  <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36&quot;</span><br>  <span class="hljs-comment"># 方法一：直接在请求头中添加Cookie内容</span><br>  <span class="hljs-string">&quot;Cookie&quot;</span>: <span class="hljs-string">&quot;Cookie值&quot;</span><br>&#125;<br><span class="hljs-comment"># 方法二</span><br>cookies = &#123;<br>  <span class="hljs-string">&quot;xx&quot;</span>: <span class="hljs-string">&quot;yy&quot;</span><br>&#125;<br><span class="hljs-comment"># 使用 POST 请求参数发送请求</span><br>response = requests.post(url, headers=headers, cookies=cookies)<br></code></pre></td></tr></table></figure><h2 id="错误证书处理"><a href="#错误证书处理" class="headerlink" title="错误证书处理"></a>错误证书处理</h2><p><a href="https://github.com/Kr1s77/Python-crawler-tutorial-starts-from-zero/blob/master/images/12306ssl%E9%94%99%E8%AF%AF.png"><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h7m6zf3zxij31510u0adi.jpg" alt="img"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入模块</span><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-comment"># 定义请求地址</span><br>url = <span class="hljs-string">&quot;https://www.baidu.com&quot;</span><br><span class="hljs-comment"># 获取响应信息</span><br><span class="hljs-comment"># 设置忽略证书</span><br>response = requests.get(url, verify=<span class="hljs-literal">False</span>) <span class="hljs-comment"># 表示为不验证CA证书</span><br></code></pre></td></tr></table></figure><h2 id="超时处理"><a href="#超时处理" class="headerlink" title="超时处理"></a>超时处理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入模块</span><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-comment"># 定义请求地址</span><br>url = <span class="hljs-string">&quot;https://www.baidu.com&quot;</span><br><span class="hljs-comment"># 设置超时秒数</span><br>response = requests.get(url, timeout=<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><h2 id="重试处理"><a href="#重试处理" class="headerlink" title="重试处理"></a>重试处理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 首先要下载retrying模块</span><br><span class="hljs-comment"># pip3 install retrying</span><br><br><span class="hljs-comment"># 导入模块</span><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> retrying <span class="hljs-keyword">import</span> retry<br><br><span class="hljs-comment"># 使用装饰器进行重试设置</span><br><span class="hljs-comment"># stop_max_attempt_number 表示最大重试次数</span><br><span class="hljs-meta">@retry(<span class="hljs-params">stop_max_attempt_number = <span class="hljs-number">3</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">purse_url</span>(<span class="hljs-params">url</span>):<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;访问url:&quot;</span>, url)<br>  <span class="hljs-comment"># 定义请求头</span><br>  headers = &#123;<br>    <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36&quot;</span><br>  &#125;<br>  <span class="hljs-comment"># 设置代理</span><br>proxies = &#123;<br>    <span class="hljs-string">&quot;http&quot;</span>:<span class="hljs-string">&quot;http://124.235.135.210:80&quot;</span><br>  &#125;<br>  <span class="hljs-comment"># 设置超时参数</span><br>  response = requests.get(url, headers=headers, proxies=proxies, timeout=<span class="hljs-number">5</span>)<br>  <span class="hljs-keyword">return</span> response.text<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>  url = <span class="hljs-string">&quot;https://www.baidu.com&quot;</span><br>  <span class="hljs-keyword">try</span>:<br>    html = purse_url(url)<br>    <span class="hljs-built_in">print</span>(html)<br>  <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-comment"># 把url记录到日志文件里面，未来进行手动分析，然后对url进行重新请求</span><br>    <span class="hljs-built_in">print</span>(e)<br></code></pre></td></tr></table></figure><h3 id="retrying模块"><a href="#retrying模块" class="headerlink" title="retrying模块"></a><code>retrying</code>模块</h3><p><code>retrying</code>模块可以通过装饰器模式对某个函数进行监控，如果该函数异常就会引发重试操作</p><h3 id="对需要重试的函数进行装饰器操作"><a href="#对需要重试的函数进行装饰器操作" class="headerlink" title="对需要重试的函数进行装饰器操作"></a>对需要重试的函数进行装饰器操作</h3><p>可以通过<code>@retry(stop_max_attempt_number=重试次数)</code>参数设置重试次数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入模块</span><br><span class="hljs-keyword">from</span> retrying <span class="hljs-keyword">import</span> retry<br><span class="hljs-comment"># 装饰器设置重试函数</span><br><span class="hljs-meta">@retry(<span class="hljs-params">stop_max_attempt_number=<span class="hljs-number">5</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">purse_url</span>():<br>  <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
      <category>爬虫</category>
      
    </categories>
    
    
    <tags>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>try--python异常处理</title>
    <link href="/2022/10/30/try-python%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/2022/10/30/try-python%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>程序在运行的时候，如果解释器遇到了一个错误，程序就会停止运行，并抛出错误信息</p><h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><p>在处理一些特殊情况时，我们可以通过异常捕获来保证程序的健壮性和稳定性</p><p>在程序开发的过程中，如果对某些代码的执行不能确定（但是语法是完全正确的），比如说在spider的时候的异常处理等</p><p>那么就可以增加<code>try</code>来进行捕获异常</p><h2 id="try-amp-except"><a href="#try-amp-except" class="headerlink" title="try&amp;except"></a><code>try</code>&amp;<code>except</code></h2><p><code>try</code>：这个关键字用来捕获异常</p><p>内部是尝试执行的代码</p><p><code>except</code>：出现错误的处理</p><h2 id="简单用法"><a href="#简单用法" class="headerlink" title="简单用法"></a>简单用法</h2><ol><li></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>  a = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入一个整数:&quot;</span>))<span class="hljs-comment"># 可能用户输入的不是数字 就会报错</span><br>  <span class="hljs-built_in">print</span>(a)<br><span class="hljs-keyword">except</span>:<br>  a = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入正确的内容:&quot;</span>))<span class="hljs-comment"># 如果用户输入的不是数字而导致错误后执行的代码</span><br>  <span class="hljs-built_in">print</span>(a)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;*&quot;</span> * <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><ol start="2"><li></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>  num = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入一个整数:&quot;</span>))<br>  result = <span class="hljs-number">8</span> / num<br>  <span class="hljs-built_in">print</span>(result)<br><span class="hljs-keyword">except</span> ZeroDivisionError:<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;0不能做除数&quot;</span>)<br><span class="hljs-keyword">except</span> ValueError:<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输入的数字不合法&quot;</span>)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;未知错误:<span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br><span class="hljs-keyword">finally</span>:<br>  <span class="hljs-comment"># 无论是否有错误，最后都会执行的代码</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;*&quot;</span> * <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><h2 id="异常传递"><a href="#异常传递" class="headerlink" title="异常传递"></a>异常传递</h2><p>一级一级的去找，最终将异常传递到主函数里面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo1</span>():<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入一个整数:&quot;</span>))<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo2</span>():<br>  <span class="hljs-keyword">return</span> demo1()<br><br><span class="hljs-keyword">try</span>:<br>  <span class="hljs-built_in">print</span>(demo2())<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;未知错误:<span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br><br><span class="hljs-built_in">print</span>(demo2())<br></code></pre></td></tr></table></figure><h2 id="主动抛出异常"><a href="#主动抛出异常" class="headerlink" title="主动抛出异常"></a>主动抛出异常</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">input_passwd</span>():<br>  <span class="hljs-comment"># 提示用户输入密码</span><br>  pwd = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入密码：&quot;</span>)<br>  <span class="hljs-comment"># 判断密码的长度</span><br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(pwd) &gt;= <span class="hljs-number">8</span>:<br>    <span class="hljs-keyword">return</span> pwd<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;主动抛出异常&quot;</span>)<br>  <span class="hljs-comment"># 创建异常对象</span><br>  ex = Exception(<span class="hljs-string">&quot;密码长度不够&quot;</span>)<br>  <span class="hljs-comment"># 主动抛出</span><br>  <span class="hljs-keyword">raise</span> ex<br><span class="hljs-comment"># 注意：只抛出异常而不捕获，代码会报错</span><br><span class="hljs-keyword">try</span>:<br>  <span class="hljs-built_in">print</span>(input_passwd())<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>  <span class="hljs-built_in">print</span>(e)<br></code></pre></td></tr></table></figure><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>也就是提前预言</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">num, div</span>):<br>  <span class="hljs-keyword">assert</span> (div != <span class="hljs-number">0</span>), <span class="hljs-string">&#x27;div不能为0&#x27;</span><br>  <span class="hljs-keyword">return</span> num/div<br><br><span class="hljs-built_in">print</span>(func(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>))<br></code></pre></td></tr></table></figure><p>会报错，但是报错的内容是 <strong>div不能为0</strong></p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
      <category>异常处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>异常处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL数据库(二)--日志系统</title>
    <link href="/2022/10/23/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%BA%8C%EF%BC%89-%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/10/23/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%BA%8C%EF%BC%89-%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL数据库（二）–日志系统"><a href="#MySQL数据库（二）–日志系统" class="headerlink" title="MySQL数据库（二）–日志系统"></a>MySQL数据库（二）–日志系统</h1><p>在（一）中分析了MySQL的基本架构，知道了一条查询语句是依次通过连接器、查询缓存、分析器、优化器、执行器的功能最后到达存储引擎</p><p>那么，一条更新语句是如何执行的呢？</p><p>我们先从一个表的一条更新语句说起,下面是一个表的创建语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> T(ID <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key, c <span class="hljs-type">int</span>);<br></code></pre></td></tr></table></figure><p>这个表有一个主键ID和一个整型字段c，如果要将ID&#x3D;2这一行的值加1，就会这么写：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> T <span class="hljs-keyword">set</span> c<span class="hljs-operator">=</span>c<span class="hljs-operator">+</span><span class="hljs-number">1</span> <span class="hljs-keyword">where</span> ID<span class="hljs-operator">=</span><span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>然后，上面所说的查询语句的流程，更新语句也会走一遍</p><p>某个表一旦更新，那么在有关这个表的所有的查询缓存都会抹去</p><p>只不过，与查询流程不一样，更新语句还涉及两个重要的日志模块：</p><ul><li>redo log（重做日志）</li><li>binlog（归档日志）</li></ul><h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p>如果每次进行更新操作时，都要将数据写入磁盘，然后磁盘再去找到相应的那条记录，然后再进行更新，那么整个过程的IO成本（寻址和上下文切换的时间成本）、查找成本都很大</p><p>为了解决这个问题，于是就有了WAL技术（Write-Ahead logging），就是，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log日志里面，并且更新内存（因为redo log是固定大小的，内存会有满的时候），这个时候更新就算完成了</p><p>之后，如果redo log没有满，InnoDB引擎就会等系统比较空闲的时候，再到磁盘里面找到对应的记录，将redo log里面的记录更新到磁盘里面去</p><p>如果redo log满了，因为InnoDB的redo log是固定大小的：<img src="https://tva1.sinaimg.cn/large/008vxvgGly1h7fgja878sj30vq0ns3yn.jpg" alt="img"></p><p><code>write pos</code>是当前记录的位置，会一边写一边后移，一直循环下去；<code>check point</code>是当前要擦除的位置，擦除记录之前要把记录写到磁盘里面去</p><p>所以写入磁盘的优先级是大于其它执行命令的，会先将数据写入磁盘，使得<code>check point</code>向后推移一部分，从而能够再次的<code>write pos</code></p><p>有了<code>redo log</code>，就有了<code>crash-safe</code>这个能力，即InnoDB引擎就可以保证即使是数据库发生了异常重启，之前提交的记录都不会丢失（数据库和<code>redo log</code>是独立的），顾名思义所以才叫日志嘛</p><p><code>redo log</code>的nb之处就在于它把随机的I&#x2F;O写成了顺序的I&#x2F;O，极大的提高了效率</p><p>将记录写在<code>redo log</code>上也是写入磁盘的，只不过和更新记录的随机I&#x2F;O不同，这个是顺序I&#x2F;O</p><h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p>从MySQL的基本架构来看，其实就分为两大块：</p><ul><li>Server层：主要负责功能实现</li><li>引擎层：负责存储相关的事宜</li></ul><p>上面提到的<code>redo log</code>是InnoDB引擎特有的日志，而在Server层也有自己的日志，那就是<code>binlog</code>(归档日志)</p><p>那么，为什么会有两份日志呢？</p><p>因为最开始MySQL是没有InnoDB引擎的，其为自带的MyISAM引擎，不具备<code>crash-frash</code>功能，<code>binlog</code>日志只能用于归档，而InnoDB是以插件的形式引入到MySQL里面的，因为<code>binlog</code>只能用于归档，所以为了<code>crash-frash</code>，就又写了一个日志为<code>redo log</code></p><p>不同：</p><ol><li><code>redo log</code>是InnoDB引擎特有的，而<code>binlog</code>是Server层的，所有的引擎都可以使用</li><li><code>redo log</code>是物理日志，记录的是“在某个数据页上做了什么修改”，而<code>binlog</code>是逻辑日志，记录语句的原始逻辑</li><li><code>redo log</code>是循环写入的，空间固定会被用完，而<code>binlog</code>是可以追加的，即记录写到大小之后会自动切换下一个，不会抹去之前的记录</li></ol><p>理解了这两个日志之后，来看看执行器和InnoDB引擎在执行<code>update</code>的时候的内部流程：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> T <span class="hljs-keyword">set</span> c<span class="hljs-operator">=</span>c<span class="hljs-operator">+</span><span class="hljs-number">1</span> <span class="hljs-keyword">where</span> ID<span class="hljs-operator">=</span><span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h7fhqqukm9j30u013zwgx.jpg" alt="img"></p><p>其中，浅色部分的是InnoDB引擎执行的，深色部分是执行器执行的</p><ul><li>对数据页在内存中的这个情况，因为InnoDB将数据加载到内存中的最小单位是16K（Linux下是4K），所以会出现要查询的数据，已经出现在内存中的情况</li><li><code>binlog</code>是写入磁盘的，其记录的是这个操作</li></ul><p>对于<code>redo log</code>的<code>prepare</code>和<code>commit</code>这两步，被称为两阶段提交</p><h2 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h2><p>对于两阶段提交，目的是为了让<code>redo log</code>和<code>binlog</code>两个日志保持逻辑一致</p><p>如果不是两阶段提交，那么就会发生下面两种情况：</p><ul><li>先<code>redo log</code>再<code>binlog</code></li><li>先<code>binlog</code>再<code>redo log</code></li></ul><p>如果是先<code>redo log</code>后<code>binlog</code>，那么当<code>redo log</code>写完记录之后，如果数据库异常crash了，那么<code>redo log</code>仍有这条结果，而对于<code>binlog</code>，是没有这个逻辑记录的，导致后面如果恢复库的时候，会使临时库里面少了一条更新</p><p>如果是先<code>binlog</code>后<code>redo log</code>，那么当<code>binlog</code>写完逻辑记录后，如果数据库异常crash了，就会导致<code>redo log</code>里面没有这个值的记录，当恢复数据库的时候，会从临时库里面多出来一条事务</p><p>这不仅会对恢复数据有影响，还会对数据库的扩容方面有影响（数据库的扩容一般是全量备份加上<code>binlog</code>来实现的）</p><p>两阶段提交的做法可以迁移到其它方面，本质上就是为了保证逻辑上的一致性</p><h2 id="数据恢复过程"><a href="#数据恢复过程" class="headerlink" title="数据恢复过程"></a>数据恢复过程</h2><p>有时DBA会说MySQL可以恢复到半个月内任意一秒的状态，这是怎么做到的？</p><p>前面提到过，<code>binlog</code>可以记录所有的逻辑操作，而且是采用追加写的方式。那么，备份系统里面，就能够保存一定时期内的所有<code>binlog</code>，同时系统会定期做整库备份（定期取决于系统的重要性）</p><p>理解了内层逻辑，至于恢复，那就是：</p><ol><li>先找到最近一次的全量备份（整库备份），从这个备份里面恢复数据到临时库</li><li>然后，从备份的时间点里面，将<code>binlog</code>一个个的拉出来，重放到删表（库）的时候</li><li>这个时候你的临时库就和删表之前的线上库一样了，你只要把临时库里面的表数据按需要恢复到线上库去即可</li></ol><p>建议将<code>innodb_flush_log_at_trx_commit</code>这个参数设置成1，可以使<code>redo log</code>都直接持久化到磁盘，可以保证MySQL数据库异常crash后数据不会丢失</p><p><code>sync_binlog</code>参数也建议设置成1，表示每次事务的<code>binlog</code>都持久化到磁盘，可以保证异常crash后<code>binlog</code>不会丢失</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL数据库(一)--基本架构</title>
    <link href="/2022/10/22/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%B8%80-%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84/"/>
    <url>/2022/10/22/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%B8%80-%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL数据库-一-–-基本架构"><a href="#MySQL数据库-一-–-基本架构" class="headerlink" title="MySQL数据库(一) – 基本架构"></a>MySQL数据库(一) – 基本架构</h1><p>大体来说，MySQL数据库可以分为以下两部分：</p><ul><li>Server层</li><li>存储引擎层</li></ul><p>Server层包括连接器、存储缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能。</p><p>存储引擎层则负责数据的存储和提取。（其架构模式是插件型的，默认为<code>InnoDB</code>存储引擎，可以在<code>creat table</code>建表的时候通过<code>engine=引擎名</code>来指定其它的引擎（<code>Memory</code> <code>MyISAM</code>））不同的存储引擎的表数据存储方式不同，支持的功能也不同。</p><p>不同的存储引擎可以共用一个Server层。</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h7dvo91up1j31400u0wi3.jpg" alt="MySQL架构图的副本"></p><p>下面，我们来走一遍流程。</p><h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><h3 id="连接操作"><a href="#连接操作" class="headerlink" title="连接操作"></a>连接操作</h3><p>第一步，你会通过连接器先连接到这个数据库上</p><p>连接器负责和客户端建立连接、获取权限、维持和管理连接</p><p>将MySQL配置好环境变量以后，可以在DOS命令窗口使用连接命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysql -h$ip -p$port -u$user -p<br></code></pre></td></tr></table></figure><p>密码可以在-p后面跟着输入，但是可能会造成密码泄露，所以一般是在交互对话时输入</p><p>如果是本机使用，默认端口为3306的话，可以简化语句：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysql -u root -p<br></code></pre></td></tr></table></figure><p>如果你是非管理员用户的话，在通过经典的TCP握手连接上MySQL后，连接器就会要求你输入你的用户名和密码来认证你的身份</p><p>认证成功后连接器就会到权限表里面查出你的拥有的权限并读取出来，此后，这个连接里面的所有的权限逻辑判断，都将依赖于读取到的权限（也就是说如果管理员在其连接时修改其权限，是不会影响其正在连接时的权限的）</p><p>连接上后，如果没有操作，这个连接就处于空闲状态，可以通过<code>processlist</code>来查看连接的用户的情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show processlist;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h7edyenbcdj30ob04jdgz.jpg" alt="img"></p><p>客户端如果如果太长时间没有动静的话，连接器就会自动将连接断开，这个过程是靠wait_timeout来控制自动断开时间的，可以查看：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">global</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;wait_timeout&#x27;</span>;<br></code></pre></td></tr></table></figure><p>默认是28800秒也就是8小时，如果想要修改可以用<code>set</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> wait_timeout<span class="hljs-operator">=</span>新时间;<br></code></pre></td></tr></table></figure><h3 id="长连接和短连接"><a href="#长连接和短连接" class="headerlink" title="长连接和短连接"></a>长连接和短连接</h3><p>在数据库里面，长连接是指一直使用同一个连接，而短连接就是指每次执行几条查询语句后，就将连接断开，再次建立起一个新的连接。</p><p><strong>建立连接的过程是比较复杂的，所以尽量使用长连接。</strong></p><p>但是呢，由于mysql在执行过程中临时使用的内存是管理在连接对象里面的，这些资源会在连接断开的时候才释放，所以，如果长时间积累下来，可能导致占用内存特别大，会因为OOM被系统强行kill掉，从现象上看就是mysql重启了</p><p>解决方案：</p><ul><li>定期断开长连接再重连</li><li>通过执行<code>mysql_reset_connection</code>（并不是终端命令而是C的API）来重新初始化连接资源，会恢复到连接刚刚建成时的状态</li></ul><h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>连接建立完成后，你就可以执行<code>select</code>语句了，这个时候就会来到查询缓存这一步</p><p>当你输入一条语句时，这条语句会经过处理后将结果返回给你，同时也会将你的查询语句和返回结果以key-value的形式缓存到内存中。当你再次输入查询语句时，会先到查询缓存里面看看，是不是之前执行过，如果有，就会直接将value返回给你，效率很高；没有，就会执行前面所说的过程</p><p>但大多数情况下不建议使用查询缓存，因为其失效非常频繁。如果一个表进行了更新，那么这张表上面所有的查询缓存都会被清空，除非你的业务是一张静态表（如系统配置表），很长时间才会更新一次</p><p>MySQL也提供了按需使用的方式，也就是说可以将参数<code>query_cache_type</code>设置成<code>DEMAND</code>，对要使用查询缓存的语句加入<code>SQL_cache</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> SQL_cache <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> T <span class="hljs-keyword">where</span> ID<span class="hljs-operator">=</span><span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p><strong>MySQL8.0将整个查询缓存功能彻底删去了</strong></p><h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><p>如果没有命中查询缓存的话，就要开始真正的执行语句了。首先，MySQL要知道你要干什么，因此会对你输入的SQL语句进行解析</p><p>分析器会先进行”词性分析”，你输入的是由字符串和空格组成的SQL语句，MySQL要知道你输入的字符串是什么，分别代表什么意思</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> T <span class="hljs-keyword">where</span> ID<span class="hljs-operator">=</span><span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>MySQL从<code>select</code>中识别出来，这是一条查询语句，然后把<code>字符串T</code>识别成<code>表T</code>，把<code>字符串ID</code>识别成<code>列ID</code>（同时也会判断是否数据库里有这些表和列）</p><p>做完这些识别以后，就要进行语法分析。如果语法不合规范的话就会报错</p><h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>经过分析器MySQL知道你要干什么之后，在开始处理之前，还要进行优化器的处理（顾名思义，就是尽可能少的搜序数据，提高速度）</p><p>优化器就是在表里面有多个索引时，决定先使用哪个索引；在一个语句有多表关联（join）的时候，决定各个表的连接顺序</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t1 <span class="hljs-keyword">join</span> t2 <span class="hljs-keyword">using</span>(ID)  <span class="hljs-keyword">where</span> t1.c<span class="hljs-operator">=</span><span class="hljs-number">10</span> <span class="hljs-keyword">and</span> t2.d<span class="hljs-operator">=</span><span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><ul><li>既可以先从表t1里面取出c&#x3D;10的记录的ID值，根据ID值关联到表t2里面，然后再判断表t2里面的d&#x3D;20</li><li>也可以先从表t2里面取出d&#x3D;20的记录的ID值，根据ID值关联到表t1里面，然后再判断表t1里面的c&#x3D;10</li></ul><p>最后的逻辑结果是一样的，但是效率不同，而优化器就是决定选择哪个方案</p><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，接下来就进入到了执行器阶段</p><p>以前面的SQL语句为例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> T <span class="hljs-keyword">where</span> ID<span class="hljs-operator">=</span><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>当执行语句时，会先进行一个权限判断，判断你对这个表T有没有查询权限，如果没有，就会返回没有权限的错误：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">ERROR <span class="hljs-number">1142</span> (<span class="hljs-number">42000</span>): <span class="hljs-keyword">SELECT</span> command denied <span class="hljs-keyword">to</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;b&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">table</span> <span class="hljs-string">&#x27;T&#x27;</span><br></code></pre></td></tr></table></figure><p>在MySQL8.0版本之前还有查询缓存的时候，如果命中了查询缓存，会在查询缓存返回结果的时候，做一次权限验证，查询也会在优化器之前调用precheck验证权限。</p><p>如果有权限，那么就打开表T执行。打开表的时候，执行器会根据表T的引擎定义，去使用这个引擎提供的API</p><p>执行流程如下：</p><ol><li>调用InnoDB引擎API（默认）去取这个表T的第一行（可能存储引擎按照页来读取，而其提供的API是按照行来读取），判断ID值是否等于10，不是就跳过，是就将这行存在结果集中</li><li>调用引擎API取下一行，重复相同的判断逻辑，直到取到最后一行</li><li>执行器将上述遍历中所有满足条件的行组成的记录集作为结果集返回给客户端</li></ol><p>执行器每次调用引擎时，都会被慢查询日志里面<code>rows_examined</code>字段通过累加记录下来这个语句执行时扫描了多少行</p><p>有时执行器扫描了一行，而存储引擎可能扫描了多行，导致引擎扫描行数和<code>rows_examined</code>的不同，这可能是因为和存储引擎提供的引擎API有关系</p><p>这样，整个MySQL大致的框架就是这样了。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
